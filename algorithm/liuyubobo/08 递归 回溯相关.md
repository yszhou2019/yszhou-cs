## 相关技术

仔细想想回溯是啥，和递归基本一样

都是一开始是终结条件，满足条件return提前终止函数；

函数体嵌套调用，不同的是，递归可能调自己一次，深搜的话，**展开多个分支调用自己**。

因为是不停的调用自己，因此递归栈加深，全部都是**依靠终结条件才能正常执行**。



___

## 递归与回溯



### 例题 17 电话号码对应的所有字母组合

sln 回溯，时间复杂度$O(3^m\times 4^n)$指数级别，所有的叶节点都遍历到，一共有$3^m \times 4^n$个叶子节点，空间复杂度主要取决于递归调用层数，最大为`m+n`

思路，dfs深搜的时候需要两个参数，第一个参数`path`，第二个参数`curIndex`

| 参数名     | 含义                                     |
| ---------- | ---------------------------------------- |
| `path`     | 深搜到当前元素的下标之前，已经形成的组合 |
| `curIndex` | 当前待考察的元素的下标（当前尚未探索）   |

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20201214175509.jpg" style="zoom:67%;" />



```cpp
class Solution {
private:
    vector<string>res;
    string path;
    unordered_map<char,string> mp{{'2',"abc"},{'3',"def"},{'4',"ghi"},{'5',"jkl"},{'6',"mno"},{'7',"pqrs"},{'8',"tuv"},{'9',"wxyz"}};
public:
    vector<string> letterCombinations(string digits) {
        if(digits.size()==0)return {};
        res.clear();
        path.clear();
        dfs(digits,0);
        return res;
    }
    void dfs(string& digits, int start)
    {
        if(start==digits.size())
        {
            res.push_back(path);
            return;
        }
        string abc=mp[digits[start]];
        for(int i=0;i<abc.size();i++)
        {
            path.push_back(abc[i]);
            dfs(digits,start+1);
            path.pop_back();
        }
    }
};
```





回溯，深搜，dfs，递归（特指深搜递归），本质上没有任何区别

都是暴力搜索，效率并不咋样



### 回溯的形式(自己总结的)

回溯？

回溯的处理形式是

```
for (遍历选择curIndex所有代表的元素)  // 实际上就是 从候选集中逐一挑选数据进行状态组合
	选择curIndex修改当前状态；// 根据可选元素组合成当前状态
	dfs(当前状态，curIndex+1)
	恢复当前状态
```

```
而dfs的参数，通常是
第一个参数，是state或者combination
第二个参数，是curIndex或者startNum // 第二个参数主要用来避免候选集中的数字多次被选择，也就是重新确认新的候选集的边界范围

```





也就是如果深搜的过程中，dfs传递的当前状态是引用的形式，那么需要{ 修改状态，dfs传递状态，恢复状态 }才能完成回溯。

但是如果`dfs传递的状态`是拷贝的形式，也就是备份，就不用再回溯复原当前状态了。

```js
var letterCombinations = function (digits) {
    let letters = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"];
    let res = [];
    if (digits == "") return res;
    // 深搜的时候需要2个参数，第一个参数保存当前组合，第二个参数指示输入数组中的当前考察元素的下标（当前尚未探索）
    function dfs(path, curIndex) {
        if (path.length == digits.length) {
            res.push(path.slice());
            return;
        }
        let letter = letters[digits[curIndex] - "0"]; // 对应的字母组合
        for (let i = 0; i < letter.length; i++) {
            dfs(path + letter[i], curIndex + 1); // 这里将拼接的结果传到dfs里面，path并不会受到影响
        }
    }
    dfs("", 0);
    return res;
}
```





### DFS与回溯的调试小技巧

在整个递归函数中打印信息进行调试。dfs函数一开始打印输出，dfs达到深度之后打印输出，dfs向下分支打印输出，dfs所有分支结束打印输出。

递归调用结束之后（所有分支结束），返回上一层。直到根节点的所有可能分支尝试完毕，整个dfs就结束了。

回溯法仍然是遍历所有可能性。动态规划本质是在回溯法的基础上进行改进，在递归结构的基础上，加上其他性质，就是动态规划。

另外回溯过程中可以剪枝，不用到达所有的叶子节点，从而提升算法效率。



### 练习题





#### 93 复原IP地址

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427200839.png" alt="image-20210427200839311" style="zoom:80%;" />



#### 131 分割回文串

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427200928.png" alt="image-20210427200928762" style="zoom:80%;" />

___





## 回溯算法的应用

排列问题

### 例题 46 全排列

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427201138.png" alt="image-20210427201138747" style="zoom:80%;" />

__

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20201214175517.jpg" style="zoom:50%;" />

取出数字之后，向下的分支不能再用

不同于q17，q17可以重复用数字

排列树 子集树（组合树）

`nums`数组中不包含重复数字，也就是全排列

sln 时间复杂度$O(n*n!)$不清楚，空间复杂度O(n)，最大递归深度即`nums`的长度n。除**答案数组**以外，**递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度** [复杂度分析](https://leetcode-cn.com/problems/permutations/solution/quan-pai-lie-by-leetcode-solution-2/)

```js
// 递归函数自动会回去 设置的其他变量如果有必要的话 也需要恢复到原来状态
// 只有未访问过的数字才能分支，其他已经访问过的数字则不能再分支
var permute = function (nums) {
    let res = [];
    if (nums == []) return res;
    let used = Array(nums.length).fill(false);
    const dfs = function () {
        if (path.length == nums.length) {
            res.push(path);
            return;
        }
        for (let i = 0; i < nums.length; i++){
            if (!used[i]) { // 用过的数字不能再分支
                // 添加到path中
                path.push(nums[i]);
                used[i] = true;
                // 分支
                dfs(path.slice());
                // 恢复
                path.pop();
                used[i] = false;
            }
        }
    }
    dfs([]);
    return res;
};
```

```cpp
class Solution {
private:
    vector<vector<int>> res;
    vector<bool> used;

    void generatePermutation(const vector<int> &nums, int idx, vector<int> &p) {
        if (idx == nums.size()) {
            res.push_back(p);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (!used[i]) {
                p.push_back(nums[i]);
                generatePermutation(nums, idx + 1, p);
                p.pop_back();
                used[i] = false;
            }
        }
    }

public:
    vector<vector<int>> permute(vector<int> &nums) {
        res.clear();
        if (nums.size() == 0) {
            return res;
        }
        vector<int> p;
        generatePermutation(nums, 0, p);
        return res;
    }
};
```





### 练习题



#### 47 全排列 II

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427201657.png" alt="image-20210427201657687" style="zoom:80%;" />

`nums`数组中可以有重复数字，最后的`res`数组返回的是不重复的全排列

sln_1 按照q46的方式，全排列之后对`res`数组去重
sln_2 剪枝dfs。时间复杂度$O(n\times n!)$，最坏不会剪枝。空间复杂度O(n)的used数组，递归栈深度O(n)，总空间复杂度O(n+n)=O(2n)=O(n)

需要剪枝，**什么情况下需要剪枝？重复数字且前面相同的数字不是路径上的祖先节点，而是同一级别的数字。（所谓同一级别，就是nums[i]对应的used==false）**从对立的角度来看，就是什么情况下才允许dfs产生分支？什么情况下直接跳过dfs？

先对`nums`数组进行排序，然后分枝。

nums中所有的数字都先遍历，进行分枝，只考虑剪枝就行了。**哪些数字需要剪枝？重复的数字需要剪枝。**

1. 之前路径上已经用过的数字，不能再用，**直接剪枝（used[i]==true，则跳过dfs）**
2. i>0&&nums[i]==nums[i-1]，（i>0保证i-1的合法），如果**数字重复**，并且used[i-1]==true，说明虽然数字相同，**但是nums[i-1]是祖先节点**，nums[i]仍然**正常dfs产生分枝**；
3. 如果**used[i-1]==false，说明是同一级别的节点**，且nums[i-1]已经经过dfs产生分枝，且回溯完毕。此时**需要剪枝**。

**used==true，则对应节点是祖先节点**

**used==false，则对应节点是尚未分枝**

**分枝是对尚未分枝的节点（used==false）进行分枝**

1. 经过（used[i]==true，则跳过dfs）过滤，当前考察的used[i]为false
2. 需要考虑，如果**used[i-1]==true，(used[i]==false)，nums[i]==nums[i-1]**，i-1是祖先节点，i未分枝，那么i那么正常分枝（那说明nums[i-1]是path路径中正在采用的节点（也就是祖先节点）,仍然可以对当前节点dfs产生分枝）；
3. 如果**used[i-1]==false，(used[i]==false)，而且nums[i]==nums[i-1]**，i-1未分枝（已经分枝完毕回溯完毕），i未分枝，那么i跳过分枝（这说明i和i-1属于并列分枝，且考虑i的时候分枝i-1已经撤销，因此此时需要剪枝(used[i]==false)）。





复杂点的分析思路

1. 继续向下分枝的过程中，**path路径上已经用过的数字，需要剪枝**（used[i]==true，则跳过dfs），保证了用过的节点不能在一个组合中多次利用
2. **并列的重复的分枝，只保留第一个分枝**
3. i==0且**经过第一步的过滤，如果i==0，那么说明第一个数字在当前组合中并没有用过，直接dfs产生分枝**。
4. 之后的i，**经过第一步的过滤，当前的数字确实可以利用，**如果和i-1对应的**数字不同**，那么说明，如果**dfs产生分枝，那么分枝不会和前一个数字的分枝重复**；
5. 如果i和i-1对应的**数字相同**，如果**i-1对应的数字已经利用过**，那么说明i-1是path路径上的节点，当前节点仍然**可以dfs向下分枝**；
6. 如果i和i-1对应的**数字相同**，如果i-1对应的数字**没有利用过**，那么说明之前已经有了以nums[i-1]的分枝，且已经回溯，**nums[i]对应的分枝会造成重复，不能dfs分枝**。

```cpp
class Solution {
private:
    vector<vector<int>>res;
    vector<int>path;
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(),nums.end()); // 首先排序
        int n=nums.size();
        vector<bool>used(n,false);
        dfs(nums,used);
        return res;
    }

    void dfs(vector<int>& nums, vector<bool>& used) {
        if(path.size()==nums.size()){
            res.push_back(path);
            return;
        }
        for(int i=0;i<nums.size();i++){
            if(used[i])continue; // 已经用过的数字当然不允许重复使用
            if(i>0 && nums[i]==nums[i-1] && used[i-1]==false)continue;
           // 数字重复，且未用过（已经产生分枝回溯完毕） 剪枝
            path.push_back(nums[i]);
            used[i]=true;
            dfs(nums, used);
            used[i]=false;
            path.pop_back();
        }
    }
};
```





## 剪枝

### 例题 77 组合

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427202253.png" alt="image-20210427202253072" style="zoom:80%;" />

__

回溯的剪枝

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427203153.png" alt="image-20210427203153667" style="zoom:80%;" />

sln 递归，不进行剪枝
sln 递归，进行剪枝

```cpp
// 不进行剪枝
class Solution {
private:
    vector<vector<int>>res;
    void process(int n,int k,int start,vector<int>&c){
        if(c.size()==k){
            res.push_back(c);
            return;
        }
        for (int i = start; i <= n; ++i) {
            c.push_back(i);
            process(n,k,i+1,c);
            c.pop_back();
        }
        return;
    }

public:
    vector<vector<int>> combine(int n,int k){
        res.clear();
        if(n<=0||k<=0){
            return res;
        }
        vector<int>c;
        process(n,k,1,c);
        return res;
    }
};
// 进行剪枝
    void process(int n, int k, int start, vector<int> &c) {
        if (c.size() == k) {
            res.push_back(c);
            return;
        }
//      进行剪枝
//      还有k-c.size()个空位，[i...n]中至少有k-c.size()个元素
//      i最多=n-(k-c.size())+1
        for (int i = start; i <= n - (k - c.size()) + 1; ++i) {
            c.push_back(i);
            process(n, k, i + 1, c);
            c.pop_back();
        }
        return;
    }
```



### 练习题

### 39 combination sum

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427203606.png" alt="image-20210427203606118" style="zoom:80%;" />

### 40 combination sum 2

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427203624.png" alt="image-20210427203624220" style="zoom:80%;" />

### 216 combination sum 3

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427203636.png" alt="image-20210427203636598" style="zoom:80%;" />

### 78 子集

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427203652.png" alt="image-20210427203652143" style="zoom:80%;" />

### 90 子集 II

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427203711.png" alt="image-20210427203711616" style="zoom:80%;" />

### 401 二进制手表

```js
var readBinaryWatch = function (num) {
    let res = [];
    let nums = [8, 4, 2, 1, 32, 16, 8, 4, 2, 1]; // 前4个是hour 后面6个是minute 
    let used = Array(10).fill(0);
    function isValid(hour, minute) {
        if (hour > 11) return false;
        if (minute > 59) return false;
        return true;
    }
    function getTime(hour, minute) {
        if (minute < 10)
            return hour + ":0" + minute;
        return hour + ":" + minute;
    }
    function dfs(startIndex, usedCnt) {
        if (usedCnt == num) {
            let hour = 0;
            for (let i = 0; i < 4; i++) {
                hour += nums[i] * used[i];
            }
            let minute = 0;
            for (let i = 4; i < 10; i++) {
                minute += nums[i] * used[i];
            }
            if (isValid(hour, minute)) {
                res.push(getTime(hour, minute));
            }
            return;
        }
        for (let i = startIndex; (i < 10) && (num - usedCnt <= 10 - i + 1); i++) { // 可以剪枝
            used[i] = 1;
            dfs(i + 1, usedCnt + 1);
            used[i] = 0;
        }
    }
    dfs(0, 0);
    return res;
};
```



## 视频8-6 8-7

### 79 word search

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427204410.png" alt="image-20210427204410502" style="zoom:80%;" />

思路是，首先扫描整个矩阵，第一个字符相等则进行展开，used标记，周围四个点（下标合法，没有访问过，字符相等）



```cpp
class Solution {
private:
    int m;
    int n;
public:
    bool exist(vector<vector<char>>& board, string word) {
        m=board.size();
        n=board[0].size();
        for(int i=0;i<m;i++)
        for(int j=0;j<n;j++)
        {
            if(board[i][j]==word[0])
            if(dfs(board,word,1,i,j))
            return true;
        }
        return false;
    }
    bool dfs(vector<vector<char>>& board, string& word, int next, int i, int j) {
        if(next==word.size())return true;
        auto tt=board[i][j];
        board[i][j]='#';
        int dx[4]={1,-1,0,0};
        int dy[4]={0,0,1,-1};
        for(int k=0;k<4;k++)
        {
            int x=i+dx[k];
            int y=j+dy[k];
            if(x>=0 && x<m && y>=0 && y<n && board[x][y]==word[next])
            if(dfs(board,word,next+1,x,y))
            return true;
        }
        board[i][j]=tt;
        return false;
    }
};
```



### 练习题

floodfill算法

#### LC200 岛屿数量

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210508184913.png" alt="image-20210508184906410" style="zoom: 50%;" />



#### LC130 包围的区域

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210508185441.png" alt="image-20210508185441063" style="zoom: 50%;" />

#### LC417 太平洋水流问题





## 视频8-8

#### 8皇后

求所有的具体解

递归回溯，思路，第一行的皇后，可以有N个位置可以放置，第一行放置了之后，放置第二行（N个位置需要把非法的位置排除掉）

所以说问题来了，怎么判断非法的位置？怎么快速判断？

引入辅助数组？

竖向：col[i]表示第i列被占用

对角线1：同一条对角线上的横纵坐标之和相等，dia1[i]表示第i条对角线被占用

对角线2：同一条对角线上的横纵坐标之差想的，dia2[i]表示第i条对角线被占用



<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210508185541.png" alt="image-20210508185541546" style="zoom:50%;" />

#### LC52 N皇后求所有解的个数

#### LC37 数独问题







# 题目参考自公众号，代码随想录

# 在一个组合中，限制数字使用一次

# 77 组合

回溯法求组合问题

直接深搜

为啥要剪枝，有些不必要的地方，一定不会搜索出来答案的地方，没必要展开，`储备的数据不足以让state成长到size = k，就是说，可用的数据不够的时候，明显不用再搜索答案了`

目的是让combination从size=0到size=k 添加 不允许重复

```js
var combine = function (n, k) {
    let res = [];
    if (k == 0) return [[]];
    // 这个函数的目的就是深搜，求出来[1...n]的所有长度为k的组合
    // 两个参数，一个是之前的状态，第二个参数 startNum 这个参数用来记录本层递归的中，集合从哪里开始遍历（集合就是[startNum,...,n] ）
    function dfs(state, startNum) {
        if (state.length == k) {
            res.push(state);
            return;
        }
        for (let num = startNum; num <= n; num++) { // num 代表下一个可以选的数据， 可选范围 [startNum ... n] => 剪枝优化 当前state中 state长度 len 剩余空间n-(k-state.length)+1 这个state没有改动之前，长度len，还需要(k-len)个元素，
            // 修改当前状态
            state.push(num)
            // 在当前状态的基础之上继续深搜
            dfs(state.slice(), num + 1);
            // 恢复状态
            state.pop();
        }
    }
    dfs([], 1);
    return res;
};
```



```cpp
class Solution {
private:
    vector<vector<int>> res;
    vector<int>path;
public:
    vector<vector<int>> combine(int n, int k) {
        dfs(1, n, k);
        return res;
    }

    void dfs(int startnum, int n, int k) {
        if(path.size()==k){
            res.push_back(path);
            return;
        }
        for(int i=startnum;i<=n;i++){
            path.push_back(i);
            dfs(i+1, n, k);
            path.pop_back();
        }
    }
};
```





**剪枝优化**

`剪枝优化 当前combination还没有改变的时候 combination size = len , 要达到size = k ，还需要(k-len)个数据， 也就是 最后一个允许的num，至少应该留出来(k-len)个数据 应该满足(n-num+1) =(k-len) 从而推出来枚举第(combination.length + 1)个数据，这个数据的范围并不是从(startNum到n)，而是从(startNum到endNum) endNum = n - ( k - combination.length) + 1`

```cpp
class Solution {
private:
    vector<vector<int>>res;
    vector<int>path;
public:
    vector<vector<int>> combine(int n, int k) {
        dfs(1, n, k);
        return res;
    }
    
    void dfs(int startnum, int n, int k) {
        if(path.size() == k){
            res.push_back(path);
            return;
        }
        // 后续可选的数字至少应该保证可以填满在path的基础上，填满k个
        // k-path.size()<=n-x+1
        // x<=n-k+1+path.size()
        for(int i=startnum;i<=n-k+1+path.size();i++){
            path.push_back(i);
            dfs(i+1, n, k);
            path.pop_back();
        }
    }
};
```





# 216 组合总和 III

从集合[1 ... 9]中挑选k个数，不允许重复（每个数字最多用一次），满足这些数的和= targetSum，求所有combination





```js
var combinationSum3 = function (k, n) {
    let res = [];
    if (k == 0 || n == 0) return res;
    function dfs(combination, startNum, curSum) { // 第三个参数可以不要
        // if(curSum > n) return; 改进 继续剪枝
        if (combination.length == k) {
            if (curSum == n)
                res.push(combination);
            return; // k个数据的时候就需要检查sum是否已经满足目标和，如果满足就加入到res，如果不满足就无功而返 也就是说，k就是深搜的最大深度
        }
        for (let i = startNum; i <= 9; i++) { // 尚未优化 候选集范围[startNum ... 9]
            combination.push(i);
            dfs(combination.slice(), i + 1, curSum + i);
            combination.pop();
        }
    }
    dfs([], 1, 0);
    return res;
};
```





```js
var combinationSum3 = function (k, n) {
    let res = [];
    if (k == 0 || n == 0) return res;
    function dfs(combination, startNum, curSum) {
        if (combination.length == k) {
            if (curSum == n)
                res.push(combination);
            return;
        }
        for (let i = startNum; i <= Math.min(n - curSum, 9); i++) { // 对候选集范围进行优化[startNum ... 9]  剪枝边界 curSum + endNum = n endNum =(n-curSum)
            combination.push(i);
            dfs(combination.slice(), i + 1, curSum + i);
            combination.pop();
        }
    }
    dfs([], 1, 0);
    return res;
};
```



# 在一个组合中，数字可以重复使用

思考一下和之前的区别，之前一个组合，数字只能够用一次，也就相当于限制了递归深度，最多达到组合的size的时候，无论是否符合条件，都需要返回（符合条件的话，多一步添加组合到结果集中）。

这里递归的终止条件，本身没有combination的size的限制，限制的是curSum。当curSum>targetSum的时候，就返回。



# q39 组合总和

候选集的特点， 没有重复数字，一个数字可以多次选择，都是正整数

combination不允许重复，没有size限制



对于组合问题，什么时间要用**startIndex**，什么时间不需要用startIndex？

如果是一个集合，求一个集合的组合，那么就需要startIndex来指示当前的位置；如果是多个集合，比如 q17 电话号码，各个集合之间不会相互影响，就不用startIndex了。

组合问题中，数字不允许重复使用，数字允许重复使用，有什么区别？

考虑一个候选集，每次发展分支的时候，允许的范围是startIndex到n。如果数字不允许重复，也就是dfs(i+1)；如果数字允许重复，也就是dfs(i)



```js
var combinationSum = function (candidates, targetSum) {
    // 求所有的combination，combination没有size限制，限制sum = targetSum
    // 候选集的数字允许重复 都是正整数
    // combination不允许重复
    if (targetSum <= 0) return [];
    let res = [];
    let len = candidates.length;
    candidates.sort((a, b) => a - b); // 这里其实完全没有必要排序
    function dfs(combination, startIndex, curSum) {
        if (curSum == targetSum) {
            res.push(combination);
            return;
        }
        // 候选集的下标范围 [startIndex len-1]
        for (let i = startIndex; i <= len - 1; i++) {
            combination.push(candidates[i]);
            if (curSum + candidates[i] <= targetSum) // 其实如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了。
                dfs(combination.slice(), i, curSum + candidates[i]); // 不用i+1了，表示可以重复读取当前的数
            combination.pop();
        }
    }
    dfs([], 0, 0);
    return res;
};
```



**剪枝**策略小结

```
对于一个节点的所有候选集，关键是 保证i处于合法的范围 && curSum+candidates[i]<=targetSum，就是继续添加条件，避免进入dfs，也就是剪枝了
```

像下面这个例子，第一个数字选择了2，第二个数字选择了2之后，考虑3和5的时候由于已经超过了targetSum，直接跳过这个循环。

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20201214175522.png" style="zoom:50%;" />



排序+剪枝 （对候选集排序，剪枝当curSum+candidate[i]<=targetSum，才dfs，如果大于就直接跳过这层for循环，结束并向上回溯）

```js
var combinationSum = function (candidates, targetSum) {
    // 求所有的combination，combination没有size限制，限制sum = targetSum
    // 候选集的数字允许重复 都是正整数
    // combination不允许重复
    if (targetSum <= 0) return [];
    let res = [];
    let len = candidates.length;
    candidates.sort((a, b) => a - b); // 这里才有必要对候选集排序，for发展多个分支的时候可以提前终止
    function dfs(combination, startIndex, curSum) {
        if (curSum == targetSum) {
            res.push(combination);
            return;
        }
        // 下标合法 且 curSum+candadte[i] 不大于targetSum，一旦大于，由于candidate经过排序，之后的candidate[i]+curSum一定大于，一定不满足sum=targetSum
        for (let i = startIndex; (i <= len - 1) && (curSum + candidates[i] <= targetSum); i++) {
            combination.push(candidates[i]);
            dfs(combination.slice(), i, curSum + candidates[i]); // 不用i+1了，表示可以重复读取当前的数
            combination.pop();
        }
    }
    dfs([], 0, 0);
    return res;
};
```



# 要求数字最多只能使用一次

# q40 combination sum

candidates 中有重复数字，并且要求解集不包含重复的组合。每个数字在每个组合中只能使用一次。

有两个特点

1. combination不允许重复，需要额外引入数组used[]（dfs的时候，candidates[i]==candidates[i-1] && used[i-1]==false说明处于同一层上）

多加了个used数组，用来进行去除重复的集合

```js
var combinationSum2 = function (candidates, target) {
    // 候选集条件，所有数字均为正整数，可能包括重复数字，并且combination不允许重复
    if (target <= 0) return [];
    candidates.sort((a, b) => a - b); // 必须要对candidate进行排序，从而所有相同的元素挨在一起，才能去重
    let res = [];
    let len = candidates.length;
    let used = Array(len + 1).fill(false);
    function dfs(combination, startIndex, curSum) {
        if (curSum == target) {
            res.push(combination);
            return;
        }
        for (let i = startIndex; (i <= len - 1) && (curSum + candidates[i] <= target); i++) { // 剪枝 可以没有，但是效率会降低
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) continue; // 分支去重 必须要有 否则答案错误
            combination.push(candidates[i]);
            used[i] = true;
            dfs(combination.slice(), i + 1, curSum + candidates[i]);
            combination.pop();
            used[i] = false;
        }
    }
    dfs([], 0, 0);
    return res;
};
```





# q131 切割回文串

采用回溯法，先切割，对于满足回文条件的substr，进行进一步的切割；如果成功切割完毕，就把切割方案存入到res中

1 切割

2 判断回文

[startIndex, endIndex]是切割区间，endIndex也就是i的取值范围[startIndex, ... , str.length - 1]

```js
var partition = function (s) {
    if (s === "") return [];
    let res = [];
    function isPalindrome(str) {
        for (let i = 0, j = str.length - 1; i < j; j--, i++)
            if (str[i] != str[j])
                return false;
        return true;
    }
    let cnt = 0;
    function dfs(combination, startIndex) {
        if (startIndex >= s.length) {
            res.push(combination); // 成功切割完毕，则保存到res中
            return;
        }
        for (let i = startIndex; i < s.length; i++) { // 截取 [startIndex ... endIndex]
            let str = s.slice(startIndex, i + 1); // Array.slice(startIndex, endIndex) 包含startIndex 不包含endIndex
            if (isPalindrome(str)) {// 切割了[startIndex, i]
                combination.push(str);// 如果是回文串，就修改combination，然后继续dfs；如果不是回文串，就直接考虑下一个分割方案
                dfs(combination.slice(), i + 1);
                combination.pop();
            }
        }
    }
    dfs([], 0);
    return res;
};
```





# q93 IP分割

这道题超难的

这道题的关键是，递归的终止条件是，小数点的数量为3。这个时候判断第四段数据，如果合法就视作一种方案；如果不合法就放弃。终止条件和[回溯算法：分割回文串](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485372&idx=1&sn=29cc3421fb742faa57824b9a626342ad&scene=21#wechat_redirect)不同了，本题明确要求只会分成4段，所以不能用切割线切到最后作为终止条件，而是分割的段数作为终止条件。分割回文串则可以分割多段。

**函数参数**

dfs()函数必须要参数startIndex，用来记录分割的位置，保证至少分割一位。（分割过的位置不能再次分割）

```js
var restoreIpAddresses = function (s) {
    // true则代表str==0或者1-255之间 否则代表00或者超过范围
    function isValid(str) {
        if (Number(str) == 0) {
            if (str.length > 1) return false;
            return true;
        }
        if (Number(str) <= 255) {
            if (str[0] == '0') return false;
            return true;
        }
        return false;
    }
    let res = [];
    function dfs(path, startIndex, pointCnt) {
        if (pointCnt == 3) { // 已经有了3段数据 只需要验证最后一段数据合法即可
            if (startIndex > s.length - 1)
                return;
            if (isValid(s.slice(startIndex))) {
                res.push(path.slice().concat(s.slice(startIndex)));
            }
            return;
        }
        for (let i = startIndex; i < s.length; i++) { // [startIndex ... i]
            const str = s.slice(startIndex, i + 1);
            if (isValid(str)) {
                dfs(path.slice().concat(str).concat('.'), i + 1, pointCnt + 1);
            } else { // 这里为什么要break，因为当str已经非法的时候，继续再截取数字到str里仍然非法，需要提前break
                break;
            }
        }
    }
    dfs("", 0, 0);
    return res;
};
```



相同的思路，不过最后是`arr.join('.')`，但是运行时间比上面的要慢。

```js
var restoreIpAddresses = function (s) {
    function isValid(str) {
        if (str == "") return false; // 由于Number("")结果为0，添加这一行为了处理str==""的情况
        if (Number(str) == 0) {
            if (str.length > 1) return false;
            return true;
        }
        if (Number(str) <= 255) {
            if (str[0] == '0') return false;
            return true;
        }
        return false;
    }
    let res = [];
    function dfs(path, startIndex, pointCnt) {
        if (pointCnt == 3) {
            if (isValid(s.slice(startIndex))) {// 第四段数据合法，则添加；否则结束
                path.push(s.slice(startIndex));
                res.push(path.join('.'));
            }
            return;
        }
        for (let i = startIndex; i < s.length; i++) {// 截取 判断是否合法
            let str = s.slice(startIndex, i + 1);
            if (isValid(str)) {
                path.push(str);
                dfs(path.slice(), i + 1, pointCnt + 1);
                path.pop();
            } else {
                break;
            }
        }
    }
    dfs([], 0, 0);
    return res;
};

```



# 78 子集

`nums`中不包含重复数字

二叉树的角度的考虑这道题，每个数字，选还是不选，两个分支

```js
var subsets = function (nums) {
    if (nums == []) return [];
    let res = []; // 没必要sort nums本身不包含重复元素
    function dfs(combination, startIndex) {
        if (startIndex >= nums.length) {
            res.push(combination);
            return;
        }
        dfs(combination.slice(), startIndex + 1);
        combination.push(nums[startIndex]);
        dfs(combination.slice(), startIndex + 1);
        combination.pop();
    }
    dfs([], 0);
    return res;
};
```



另外一种角度是，不断生成的过程中将path添加到res中（深度优先生成的树刚好和之前求n个数字的和为k一样，因此只需要保存中间的结果）

这种方法，从dfs树的角度看，第0层dfs，刚好加入了个[]，第一层，刚好把所有的单元素集合都添加过了，第二层，刚好是所有的2个元素的集合...最后一层，刚好就是全集，也就是一个分支。**每层刚好是$C_n^k$**

要做的事情就是正常进行dfs，带有去重的那种，然后dfs的入口自动收集元素。

```js
var subsets = function (nums) {
    if (nums == []) return [];
    let res = []; // 没必要sort nums本身不包含重复元素
    function dfs(combination, startIndex) {
        res.push(combination.slice());
        if(startIndex >= nums.length){
			return; // 没必要加，因为startIndex 如果=length，那么下面的循环不会展开，从而函数直接结束
        }
        for (let i = startIndex; i < nums.length; i++){
            combination.push(nums[i]);
            dfs(combination.slice(), i + 1);//添加完nums[i]之后，combination待收集，进入dfs中
            combination.pop();
        }
    }
    dfs([], 0);
    return res;
};
```



# q90 子集 2

nums中可能有重复数字，但是结果中不能包含重复子集

```js
var subsetsWithDup = function(nums) {
    if (nums == []) return [];
    let res = [];
    nums.sort((a, b) => b - a);
    let used = Array(nums.length).fill(false);
    function dfs(combination, startIndex) {
        res.push(combination);
        for (let i = startIndex; i < nums.length; i++){
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) continue;
            combination.push(nums[i]);
            used[i] = true;
            dfs(combination.slice(), i + 1);
            combination.pop();
            used[i] = false;
        }
    }
    dfs([], 0);
    return res;
};
```





# q491 递增子序列

给定的nums数组可能乱序，可能包含重复元素。

子序列满足非严格递增，长度最少是2，子序列不允许重复。

如何保证层角度的**分支去重**。用set记录已经用过的数字，for循环如果发现set使用过，那么就剪枝。

怎么保证**序列递增**。nums[i]>path[path.length-1]，用path非空保证上述操作合法。

如果不递增，或者分支重复，就跳过nums[i]。

```js
var findSubsequences = function (nums) {
    if (nums == []) return [];
    let res = [];
    // 禁止排序 然后dfs
    function dfs(path, startIndex) {
        if (path.length > 1)
            res.push(path);
        let set = new Set();
        for (let i = startIndex; i < nums.length; i++) {
            if ((path.length > 0 && nums[i] < path[path.length - 1]) // 保证序列递增
                || (set.has(nums[i]))) continue; // 保证分支不重复
            set.add(nums[i]);
            path.push(nums[i]);
            dfs(path.slice(), i + 1);
            path.pop();
        }
    }
    dfs([], 0);
    return res;
};
```



# q46 全排列问题

全排列，所有节点进行for分支的时候，全部从index=0到最后进行分支，不过内部需要用used进行判断是否用过。**每层从0开始搜索而不是从startIndex**。

所有的叶子节点的深度相同，==nums.length，只收集叶子节点。

用used数组记录当前路径中用过的元素，从而向下深入的时候分支越来越少。

dfs函数终于不需要startIndex参数了，只需要一个path变量保存路径。

```js
var permute = function (nums) {
    let res = [];
    if (nums == []) return res;
    let used = Array(nums.length).fill(false);
    function dfs(path) {
        if (path.length == nums.length) {
            res.push(path);
            return;
        }
        for (let i = 0; i < nums.length; i++){
            if (used[i]) continue;
            used[i] = true;
            path.push(nums[i]);
            dfs(path.slice());
            path.pop();
            used[i] = false;
        }
    }
    dfs([]);
    return res;
};
```



# q47 全排列问题 2



nums中可包含重复数字，全排列不允许重复。



```js
var permuteUnique = function (nums) {
    if (nums == []) return [];
    let res = [];
    nums.sort((a, b) => a - b);
    let used = Array(nums.length).fill(false);
    function dfs(path) {
        if (path.length == nums.length) {
            res.push(path);
            return; // 其实没必要，因为所有的数字都是used=true了，下面的for循环都不会展开分支
        }
        for (let i = 0; i < nums.length; i++){
            if (used[i]) continue;
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) continue;
            used[i] = true;
            path.push(nums[i]);
            dfs(path.slice());
            path.pop();
            used[i] = false;
        }
    }
    dfs([]);
    return res;
}
```



# q332 飞机行程安排



实际上给出的解法是采用两级map，用tickets初始化map之后，进行dfs更改状态。不太清楚。

实际上是用数据结构把图的建模转化成了初始化遍历，然后dfs。

下面的代码没有得到正确答案，原因在于JS没有ordered_map

```js
var findItinerary = function (tickets) {
    let res = ["JFK"];
    let targets = new Map(); // 出发城市 [到达城市，0/1可用标志]
    for (let i = 0; i < tickets.length; i++) {
        if (targets.has(tickets[i][0])) {
            let map = targets.get(tickets[i][0]);
            if (map.has(tickets[i][1])) {
                map.set(tickets[i][1], map.get(tickets[i][1]) + 1);
            } else {
                map.set(tickets[i][1], 1);
            }
        } else {
            let map = new Map();
            map.set(tickets[i][1], 1);
            targets.set(tickets[i][0], map);
        }
    }
    for (let [key, map] of targets) {
        let arr = Array.from(map);
        arr.sort((a, b) => a[1] - b[1]); // 这里的map不能正常按照key进行排序，正确的做法是按照key的字典序排序，JS有点坑，没有ordered_map
        map = new Map(arr.map(item => [item[0], item[1]]));
    }
    function dfs(ticketNum) {
        if (res.length == ticketNum + 1) return true;
        let map = targets.get(res[res.length - 1]);
        for (let [key, value] of map) { // 遍历 Map 的方式
            if (value > 0) {
                res.push(key);
                value--;
                if (dfs(ticketNum)) return true;
                res.pop();
                value++;
            }
        }
        return false;
    }
    dfs(tickets.length);
    return res;
};
```



```cpp
class Solution {
private:
// unordered_map<出发机场, map<到达机场, 航班次数>> targets
unordered_map<string, map<string, int>> targets;
bool backtracking(int ticketNum, vector<string>& result) {
    if (result.size() == ticketNum + 1) {
        return true;
    }
    for (pair<const string, int>& target : targets[result[result.size() - 1]]) {
        if (target.second > 0 ) { // 记录到达机场是否飞过了
            result.push_back(target.first);
            target.second--;
            if (backtracking(ticketNum, result)) return true;
            result.pop_back();
            target.second++;
        }
    }
    return false;
}
public:
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        targets.clear();
        vector<string> result;
        for (const vector<string>& vec : tickets) {
            targets[vec[0]][vec[1]]++; // 记录映射关系
        }
        result.push_back("JFK"); // 起始机场
        backtracking(tickets.size(), result);
        return result;
    }
};
```



# 51 N皇后

这里的dfs还是比较好理解的，dfs和之前的回溯基本上一样。先收集结果，然后展开分支，展开分支之前对分支进行判断。

step  产生棋盘
step 2 dfs，生成所有可能性，用valid排除，到达终止条件则回收棋盘

```cpp
class Solution {
private:
    vector<vector<string>> res;
    int size;
public:
    vector<vector<string>> solveNQueens(int n) {
        // 1 产生棋盘
        vector<string> board(n,string(n,'.'));
        size=n;

        // 2 dfs产生状态，在dfs的终止条件中回收棋盘
        dfs(board, 0);

        return res;
    }

    // row代表当前放置的Queen数量
    void dfs(vector<string>& board, int row) {
        // 放置完毕，则记录一次棋盘状态
        if(row==size){
            res.push_back(board);
            return;
        }
        for(int i=0;i<size;i++)
        if(valid(board, row, i))
        {
            board[row][i]='Q';
            dfs(board, row+1);
            board[row][i]='.';
        }
    }

    bool valid(vector<string>& board, int row, int col) {
        for(int i=0;i<row;i++)
        if(board[i][col]=='Q')return false;
        
        for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--)
        if(board[i][j]=='Q')return false;

        for(int i=row-1,j=col+1;i>=0&&j<size;i--,j++)
        if(board[i][j]=='Q')return false;

        return true;
    }
};
```







# 37 数独问题

**==TODO 不太清楚==**。这里的dfs，dfs函数带有返回值，而且没有之前的收集结果步骤。另外就是遍历完毕之后也有返回值。



最终的限制条件和中间的限制条件不一样，最终的限制条件是行 列必须出现1-9，中间过程中的限制是，我们要在[i,j]的位置放置val，需要检查同行，同列，以及i,j所在的小正方形中，是否存在某个单元和val相等，如果不存在则代表可以在i,j放置val。

```cpp
class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {
        dfs(board);
        return;
    }

    // 关键是这里的dfs有返回值，用来判断是否搜到目标状态
    bool dfs(vector<vector<char>>& board) {
        for(int i=0;i<9;i++)
        for(int j=0;j<9;j++)
        {
            if(board[i][j]=='.')
            {
                for(int k=1;k<=9;k++)
                if(valid(board, i, j, k+'0'))
                {
                    board[i][j]=k+'0';
                    if(dfs(board))return true;
                    board[i][j]='.';
                }
                return false; // 9个数字都是试完了
            }
        }
        return true;
    }

    bool valid(vector<vector<char>>& board, int row, int col, int val) {
        for(int i=0;i<9;i++){
            if(board[row][i]==val)return false;
            if(board[i][col]==val)return false;
        }
        int startRow=(row/3)*3;
        int startCol=(col/3)*3;
        for(int i=startRow;i<startRow+3;i++)
        for(int j=startCol;j<startCol+3;j++)
        if(board[i][j]==val)return false;
        return true;
    }
        
};
```





___





## 二维平面上使用回溯 floodfill

**二维平面上使用回溯**

### 79 单词搜索



[参考自](https://leetcode-cn.com/problems/word-search/solution/hui-su-suan-fa-qiu-jie-by-sdwwld-2/)

```cpp
class Solution {
private:
    int m;
    int n;
public:
    bool exist(vector<vector<char>>& board, string word) {
        m=board.size();
        n=board[0].size();
        for(int i=0;i<m;i++)
        for(int j=0;j<n;j++)
        {
            if(board[i][j]==word[0])
            if(dfs(board,word,1,i,j))
            return true;
        }
        return false;
    }
    bool dfs(vector<vector<char>>& board, string& word, int next, int i, int j) {
        if(next==word.size())return true;
        auto tt=board[i][j];
        board[i][j]='#';
        int dx[4]={1,-1,0,0};
        int dy[4]={0,0,1,-1};
        for(int k=0;k<4;k++)
        {
            int x=i+dx[k];
            int y=j+dy[k];
            if(x>=0 && x<m && y>=0 && y<n && board[x][y]==word[next])
            if(dfs(board,word,next+1,x,y))
            return true;
        }
        board[i][j]=tt;
        return false;
    }
};
```









### 200 岛屿数量

floodfill算法

遍历表格，每个为1的单元格，进行floodfill传染。一次感染一块，也就是一个岛屿。

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int res=0;
        int m=grid.size();
        int n=grid[0].size();
        for(int i=0;i<m;i++)
        for(int j=0;j<n;j++)
        if(grid[i][j]=='1')
        {
            fill(grid,i,j);
            res++;
        }
        return res;
    }
    void fill(vector<vector<char>>& grid,int i, int j) {
        grid[i][j]='a';
        int dx[4]={1,-1,0,0};
        int dy[4]={0,0,1,-1};
        int m=grid.size();
        int n=grid[0].size();
        for(int k=0;k<4;k++){
            int x=i+dx[k];
            int y=j+dy[k];
            if(x>=0&&x<m&&y>=0&&y<n&&grid[x][y]=='1')
            fill(grid,x,y);
        }
    }
};
```







### 练习题

### 130 包围的区域

思路，不对内部进行floodfill，==只对四条边界进行floodfill==
fill完毕之后，遍历一遍，是O则换成X，是-则恢复成O



[参考自](https://leetcode-cn.com/problems/surrounded-regions/comments/8717)



```cpp
class Solution {
private:
    int m;
    int n;
public:
    void solve(vector<vector<char>>& board) {
        m=board.size();
        n=board[0].size();

        // 先感染4条边界
        for(int i=0;i<n;i++){
            if(board[0][i]=='O')
            dfs(board,0,i);
            if(board[m-1][i]=='O')
            dfs(board,m-1,i);
        }
        for(int i=0;i<m;i++){
            if(board[i][0]=='O')
            dfs(board,i,0);
            if(board[i][n-1]=='O')
            dfs(board,i,n-1);
        }

        // 遍历一遍，把中间的'O'替换成'X'，把中间状态'-'恢复成'O'
        for(int i=0;i<m;i++)
        for(int j=0;j<n;j++)
        if(board[i][j]=='O')
        board[i][j]='X';
        else if(board[i][j]=='-')
        board[i][j]='O';
        return;
    }
    
    // 将周围的'O'全部换成中间状态'-'
    void dfs(vector<vector<char>>& board, int i, int j) {
        board[i][j]='-';
        int dx[4]={1,-1,0,0};
        int dy[4]={0,0,1,-1};
        for(int k=0;k<4;k++){
            int x=dx[k]+i;
            int y=dy[k]+j;
            if(x>=0&&x<m && y>=0&&y<n&&board[x][y]=='O')
            dfs(board,x,y);
        }
    }
};
```







### 417 太平洋水流问题

思路，类似于130，仍然是从边界向内部进行扩展。不过这里的floodfill是，新的地点的val>=旧的地点的val，也就是“水向高处流”。

最后求的是陆地的坐标，这些陆地既能向太平洋流水，又能向大西洋流水。

[参考自](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/comments/272655)

```js
var pacificAtlantic = function (matrix) {
    let row = matrix.length;
    if (row == 0) return [];
    let col = matrix[0].length;
    if (col == 0) return [];
    let Pacific = new Array(row);
    let Atlantic = new Array(row);
    for (let i = 0; i < row; i++) {
        Pacific[i] = new Array(col).fill(false);
        Atlantic[i] = new Array(col).fill(false);
    }
    let res = [];
    let d = [[1, 0], [-1, 0], [0, 1], [0, -1]];
    function isValid(i, j) {
        if (i < 0 || i >= row || j < 0 || j >= col) return false;
        return true;
    }
    function dfs(used, i, j) { // 核心算法仍然是floodfill，不过不同的是水向高处流
        used[i][j] = true;
        for (let k = 0; k < 4; k++) {
            let newX = i + d[k][0];
            let newY = j + d[k][1];
            if (isValid(newX, newY) && used[newX][newY] == false && matrix[newX][newY] >= matrix[i][j])
                dfs(used, newX, newY);
        }
    }
    // 分别向内部进行侵蚀
    for (let i = 0; i < row; i++) {
        dfs(Pacific, i, 0);
        dfs(Atlantic, i, col - 1);
    }
    for (let j = 0; j < col; j++) {
        dfs(Pacific, 0, j);
        dfs(Atlantic, row - 1, j);
    }
    // 同时被两个侵蚀，则满足要求
    for (let i = 0; i < row; i++) {
        for (let j = 0; j < col; j++) {
            if (Pacific[i][j] && Atlantic[i][j]) {
                res.push([i, j]);
            }
        }
    }
    return res;
};
```











**回溯法是人工智能的基础**

### 51 N皇后问题





### 练习题

### 52 N皇后问题 2

```cpp
class Solution {
private:
    int size;
    int res=0;
public:
    int totalNQueens(int n) {
        size=n;
        vector<string>board(n,string(n,'.'));
        dfs(board,0);
        return res;
    }

    // row代表当前放置的Queen数量
    void dfs(vector<string>& board, int row) {
        // 放置完毕，则记录一次棋盘状态
        if(row==size){
            res++;
            return;
        }
        for(int i=0;i<size;i++)
        if(valid(board, row, i))
        {
            board[row][i]='Q';
            dfs(board, row+1);
            board[row][i]='.';
        }
    }

    bool valid(vector<string>& board, int row, int col) {
        for(int i=0;i<row;i++)
        if(board[i][col]=='Q')return false;
        
        for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--)
        if(board[i][j]=='Q')return false;

        for(int i=row-1,j=col+1;i>=0&&j<size;i--,j++)
        if(board[i][j]=='Q')return false;

        return true;
    }
};
```





### 37 数独

```cpp
class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {
        dfs(board, 0);
        return;
    }

    // 关键是这里的dfs有返回值，用来判断是否搜到目标状态
    bool dfs(vector<vector<char>>& board, int idx) {
        while(idx<81)
        {
            int i=idx/9;
            int j=idx%9;
            if(board[i][j]=='.')
            {
                for(int k=1;k<=9;k++)
                if(valid(board, i, j, k+'0')) //!!! 要放置的val是char! 不是int!
                {
                    board[i][j]=k+'0';
                    if(dfs(board, idx+1))return true;
                    board[i][j]='.';
                }
                return false;
            }
            idx++;
        }
        return true;
    }

    bool valid(vector<vector<char>>& board, int row, int col, int val) {
        for(int i=0;i<9;i++){
            if(board[row][i]==val)return false;
            if(board[i][col]==val)return false;
        }
        int startRow=(row/3)*3;
        int startCol=(col/3)*3;
        for(int i=startRow;i<startRow+3;i++)
        for(int j=startCol;j<startCol+3;j++)
        if(board[i][j]==val)return false;
        return true;
    }
        
};
```

