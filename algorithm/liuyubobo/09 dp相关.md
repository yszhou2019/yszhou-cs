



## ？？？

[参考自，不在目录中的一篇文章](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484524&idx=1&sn=302941466dbf594709b5436a59f8b06c&source=41#wechat_redirect)

普通的递归（无记忆的递归）->记忆化的递归（用数组对结果进行存储）->记忆化，非递归（记忆化，迭代）数组+迭代直接出结果，这就是动规

记忆化递归实际上就是对原先的递归树进行剪枝，从而减少子问题的个数

递归算法的时间复杂度怎么算？子问题个数乘以解决一个子问题需要的时间。子问题个数减少了，整个的递归算法的时间也就减少了。

记忆化递归和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。

对于斐波那契数列，size=n的数组可以进一步用size=2的数组进行替代，只需要保存之前的两个状态（整体转移方程中，**当前状态只和前两个状态有关，不需要dp数组保存所有的状态，只需要保存前两个状态即可**，空间进一步优化为O(1)）



### 最优子结构

**最优子结构**就是说，**子问题能不能同时取得最优解**，如果不能同时取最优解，说明子问题之间存在依赖，不是相互独立的。如果能够同时取得最优解，说明子问题彼此独立。最优子结构的性质，原问题的最优解=各个子问题的最优解。要符合最优子结构，子问题之间必须独立。

子问题独立，从而满足最优子结构。从而可以利用状态转移方程得到原问题的最优解。



“动态规划”和"递归问题"的关系，是什么呢？

递归问题，一个大的问题，可以分解成小问题，**小问题之间是重复的**。如果能够将小问题的结果保存起来，**也就是记忆化搜索，每个问题只求解一次**，小问题的数量将减少很多，从而加速最终结果的计算。**重复子问题**

递归的过程，实际上是**自顶向下**求解问题。分解出来小问题之后，最后一步步回溯累加结果得到最终结果。

### 动态规划

动态规划则是分析完毕小问题和大问题之间的关系之后，直接**从小到大一步步推算出来**最终结果。只需要迭代，不需要函数调用，不存在递归栈。



## 动态规划例题



### ~~70 爬楼梯~~

> // dp[i]代表爬到i层，一共有多少种方法
> // **怎么得到状态转移方程**
> // 爬到i层的方法={爬到(i-1)层，然后爬一层的方法数量}+{爬到(i-2)层，然后跳两层的方法数量}
> // 从而，dp[i]=dp[i-1]+dp[i-2]

```js
var climbStairs = function (n) {
    let dp = new Array(n + 1).fill(0);
    dp[0] = 0, dp[1] = 1, dp[2] = 2;
    for (let i = 3; i <= n; i++){
        dp[i] = dp[i - 2] + dp[i - 1];
    }
    return dp[n];
};
```

时间空间都是O(n)

空间可以优化，状态i只和前两个状态有关，空间优化之后是O(1)



### ~~120 三角形最小路径和 二维dp~~

**暴力递归改动态规划，然后优化一下空间就行了**
暴力递归思路，需要两个坐标，process(i, j)代表含义：**从(i, j)坐标开始，向下**，能够得到的最小路径和

```
if i == 最后一行
	return triangle[i][j]
	return triangle[i][j] + min( process(i+1, j), process(i+1, j+1));
```







### ~~746 最小代价爬楼梯~~

暴力递归

```bash
# 暴力思路
int process(idx) # 从idx开始，爬楼梯，返回值代表最小代价
	idx==cost.size(), return 0
	return cost[idx]+min(process(idx+1), process(idx+2))
```



改成动态规划

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n=cost.size();
        if(n==0){
            return 0;
        }
        vector<int> dp(n+1,0);
        dp[n]=0;
        dp[n-1]=cost[n-1];
        for(int i=n-2;i>=0;i--){
            dp[i]=cost[i]+min(dp[i+1],dp[i+2]);
        }
        return min(dp[0],dp[1]);// 一开始可以从idx=0开始，也可以从idx=1开始
    }}
};
```





> // dp[i]代表到i层花费的最小代价
> // dp[i]=min{dp[i-2],dp[i-1]}+cost[i]
> // 转移方程，到达i层的最小代价=登上i层的代价+min(i-2层的代价，i-1层的代价)
> // 根据样例，增加了最后一层台阶方便理解，最后一层台阶的cost=0

```js
var minCostClimbingStairs = function (cost) {
    let size = cost.length;
    let dp = new Array(size + 1).fill(0);
    dp[0] = cost[0], dp[1] = cost[1];
    cost.push(0);
    for (let i = 2; i <= size; i++) {
        dp[i] = Math.min(dp[i - 2], dp[i - 1]) + cost[i];
    }
    return dp[size];
};
```

时间空间O(n)

空间可以优化到O(1)





[参考自](https://leetcode-cn.com/problems/triangle/solution/shou-hua-tu-jie-dp-si-lu-120-san-jiao-xing-zui-xia/)

这道题明显不能采用贪心算法

无论怎么样，从时间复杂度角度考虑，都是需要把整个二维数组遍历完才能获得正确答案（考虑特殊情况，其他数据全部相同，只有最后一行最后一个元素为0）也就是说只有遍历完，才能保证结果的正确性。

基本思路，自顶向下选择，每个节点的两个子节点是不知道怎么选择的。但是自底向上，就可以清楚该怎么选择了。

这种方法的时间复杂度O(n^2)，空间复杂度实际上相当于拷贝了一份triangle，所以是O(n^2)

**一般来说，算法问题都是不允许修改输入的。除非有些问题就是需要我们原地操作**

```js
var minimumTotal = function(triangle) {
    let h = triangle.length;
    for (let i = h - 2; i >= 0; i--){ // 自底向上遍历，状态转移方程dp[i][j]+=Min(dp[i+1][j],dp[i+1][j+1])
        for (let j = 0; j < triangle[i].length; j++){
            triangle[i][j] += Math.min(triangle[i + 1][j], triangle[i + 1][j + 1]);
        }
    }
    return triangle[0][0]; // 最终结果dp[0][0]
};
```

dp数组降为一维数组（为什么可以直接采用一维数组呢？因为采用计算过的数据只需要用一次（说不太清楚）。

```js
var minimumTotal = function (triangle) {
    let h = triangle.length;
    let dp = triangle[h - 1].slice();
    for (let i = h - 2; i >= 0; i--){
        for (let j = 0; j < triangle[i].length; j++){
            dp[j] = Math.min(dp[j], dp[j + 1]) + triangle[i][j];
        }
    }
    return dp[0];
};
```



___

## 背包问题

### ~~0-1背包问题~~

背包容量W，有n种物品，每件物品重量为w(i)，价值为v(i)
问，怎么选择物品，使得物品的总价值最大

sln-1 暴力算法，O(n*2^n)，每件商品选/不选，一共有2^n种方案，对价值求和，时间为n
sln-2 递归（重叠子问题，最优子结构）时间O(mn)，空间O(mn)，空间可以优化到O(n)



```js
function backpack(W, w, v) {
    let n = w.length;
    let dp = new Array(n + 1);
    for (let i = 0; i <= n; i++) {
        dp[i] = new Array(W + 1).fill(0);
    }
    for (let i = 0; i < n; i++) {
        for (let j = 0; j <= W; j++) {
            if (j < w[i]) // 背包容量装不下商品i
                dp[i + 1][j] = dp[i][j];
            else // 背包容量装的下，需要考虑一下最优
                dp[i + 1][j] = Math.max(dp[i][j], dp[i][j - w[i]] + v[i]);
        }
    }
    return dp[n][W];
}
```





### ~~0-1背包~~

>
>
>每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是O(2^n)，这里的n表示物品数量。**所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！**
>
>时间空间O(m*n)



```js
/**
 * 有size个物品，重量为weight,价值为value，背包最大允许重量bagWeight，问背包最多装下的物品价值
 * 0-1背包问题
 * dp[i][j]，0-i的商品，背包重量j，装的最大价值
 * 转移方程，如果weight[i]>j，那么dp[i][j]=dp[i-1][j]
 *      如果weight[i]<=j,那么dp[i][j]=max{dp[i-1][j],dp[i-1][j-weight[i]]+value[i]}
 * 初始化，第一列，对应背包最大允许重量=0，dp=0
 *      第一行，当背包重量>=wight[0]的时候，dp=value[0]
 * 最终结果，dp[size-1][bagWeight]
 */
var backProblem = function (weight, value, bagWeight) {
    let size = weight.length;
    let dp = new Array(size);
    for (let i = 0; i < size; i++)dp[i] = new Array(bagWeight + 1).fill(0);
    // 边界初始化
    for (let i = 0; i < size; i++)
        if (weight[i] <= i)
            dp[0][i] = value[0];
    for (let i = 1; i < size; i++) {
        for (let j = 0; j <= bagWeight; j++) {
            if (weight[i] <= j) // 如果i对应的商品，背包可以装得下，就需要考虑该不该装
                dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }
    return dp[size - 1][bagWeight];
};
```





### ~~0-1背包状态压缩~~

>
>
>二维dp数组压缩成一维dp数组的时候，由于dp[i]计算用到了左上角的信息，因此从左到右的顺序计算dp[i]，会导致数据被覆盖，后面列计算对应的dp的时候，前一行的数据已经丢失。因此需要从右到左，从而避免。
>
>空间优化为O(n)



```js
/**
 * 有size个物品，重量为weight,价值为value，背包最大允许重量bagWeight，问背包最多装下的物品价值
 * 0-1背包问题
 * dp[i][j] 表示从下标为[0-i]的商品中挑选，放入背包重量j中，价值总和的最大值
 * 一维dp的时候，由于dp[i][j]用到了左上角的数据，如果还是从上到下，从左到右的顺序遍历，会覆盖数据，计算后面列的数据的时候，前面列的数据已经被覆盖，因此只能从右到左
 */
var backProblem = function (weight, value, bagWeight) {
    let size = weight.length;
    let dp = new Array(bagWeight + 1).fill(0);
    for (let i = 0; i < size; i++) { // 物品
        for (let j = bagWeight; j >= 0; j--) { // 背包重量
            if (weight[i] <= j)
                dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    return dp[bagWeight];
};
```



## 机器人走路

都是左上到右下，
62 是求方案数量
63 是，有障碍物，求方案数量
64 是，求最小路径和

都是动态规划



### ~~62 不同路径~~

从左上角到达右下角，一共有多少种方法



暴力递归思路，

```bash
int process ( i, j ) # 从i,j开始出发，达到右下角的方案数量
	i == m-1 return 1
	j == n-1 return 1
	return process(i+1, j) + process(i, j+1)
```



> `// dp[i][j]代表到达(i,j)的路径数量`
> `// 转移方程，dp[i][j]=dp[i-1][j]+dp[i`][j-1]
> `// 初始条件，左侧一列为dp元素为1，第一行dp元素为1`
> `// 最终结果dp[m-1][n-1]`

```js
var uniquePaths = function (m, n) {
    let dp = new Array(m);
    for (let i = 0; i < m; i++)
        dp[i] = new Array(n).fill(1);
    for (let i = 1; i < m; i++){
        for (let j = 1; j < n; j++){
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];    
};
```

可以空间压缩到O(n)而不是O(m*n)



### ~~63 带障碍物的不同路径~~

>
>
>统一套路可解决，
>状态压缩的DP相比于不进行状态压缩的DP，逻辑处理上多了一步

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        if(obstacleGrid.size()==0||obstacleGrid[0].size()==0){
            return 0;
        }
        int m =obstacleGrid.size();
        int n =obstacleGrid[0].size();
        vector<long>dp(n,0);
        for(int i=n-1;i>=0;i--){
            if(obstacleGrid[m-1][i]==0){
                dp[i]=1;
            }else{
                break;
            }
        }
        for(int i=m-2;i>=0;i--){
            for(int j=n-1;j>=0;j--){
                if(j==n-1){
                    dp[j]=obstacleGrid[i][j]==0?dp[j]:0;
                }else if(obstacleGrid[i][j]==0){
                    dp[j]+=dp[j+1];
                }else{ // 相比于不进行状态压缩，多了这一步（清理每一步的状态）
                    dp[j]=0;
                }
            }
        }
        return dp[0];
    }
```



时间空间O(m*n)，空间可压缩到O(n)

采用动态规划进行解决

```js
// dp[i][j]，到达(i,j)的路径数量
// 转移方程，d[i][j]=dp[i-1][j]+dp[i][j-1]
// 结果，dp[m-1][n-1]
var uniquePathsWithObstacles = function (obstacleGrid) {
    let m = obstacleGrid.length;
    let n = obstacleGrid[0].length;
    let dp = new Array(n).fill(0);
    for (let i = 0; i < n; i++)
        if (obstacleGrid[0][i] == 0)
            dp[i] = 1;
        else
            break;
    for (let i = 1; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (obstacleGrid[i][j] == 1)
                dp[j] = 0;
            else if (j > 0) // 这里不需要考虑第一列，因为如果第一列有障碍物，那么dp[0]=0,之后的dp[0]也是0，如果没有障碍物，那么dp[0]=1，始终保持不变
                dp[j] += dp[j - 1];
        }
    }
    return dp[n - 1];
};
```



### ~~64 左上到右下最小和~~

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m=grid.size();
        int n=grid[0].size();
        vector<vector<int>> dp (grid);
        for(int i=1;i<n;++i){
            dp[0][i]+=dp[0][i-1];
        }
        for(int i=1;i<m;++i){
            dp[i][0]+=dp[i-1][0];
        }
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];
            }
        }
        return dp[m-1][n-1];
    }

// private:
//     int m, n;
//     int process(vector<vector<int>>&grid, int i, int j){
//         if(i==m-1&&j==n-1){
//             return grid[i][j];
//         }
//         if(i==m-1){
//             return grid[i][j]+process(grid,i,j+1);
//         }
//         if(j==n-1){
//             return grid[i][j]+process(grid,i+1,j);
//         }
//         return grid[i][j]+min(process(grid,i,j+1),process(grid,i+1,j));
//     }
};
```



暴力递归，然后改成DP，然后优化空间

暴力递归思路，

```bash
process(grid, i , j) # 表示从i,j坐标为起点，到达右下角，的最小累加和
	(i, j)==右下角，直接返回grid[i][j]
	i == 最后一行
		return grid[i][j]+process(grid, i , j+1) # 累加和=当前的数字+之后的累加和
	j == 最后一列
		return grid[i][j]+process(grid,i+1, j)
	return grid[i][j]+min(process(i,j+1), process(i+1,j))
```





____

## LCS LIS



### ~~300 最长上升子序列 LIS~~

求给定序列的LIS的长度
严格递增，可以离散，最长长度

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427180049.png" alt="image-20210427172343133" style="zoom:80%;" />



LIS(i) **必须以i结尾**的最长LIS的长度
子串要求连续，**子序列不要求连续**。

解法0，暴力解法，时间O(2^n*n)
解法1，**动态规划，时间O(n^2)，空间O(n)**
解法2，时间O(nlogn)

这里的DP实际上是暴力遍历，时间O(n^2)
构造DP数组的时候，dp[i] 代表含义， **以第i个数字结尾的LIS的长度**
dp[ i ] 初始化为1
转移方程
dp[ i ] = max( dp[ j ] ) + 1 ，j在i之前，并且要求arr[ j ] < arr[ i ]

**初始情况**

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427171550.png" style="zoom:80%;" />

生成的dp数组并不具有单调性，比如下面的例子

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427192407.png" alt="image-20210427192407909" style="zoom:80%;" />



时间O(n^2) 空间O(n)

```cpp
// 要求谁，给定数组的LIS的长度
// 1 定义？LIS(i) 以i结尾的LIS的长度
// 2 初始化？ 全部都是1（每个子序列最少包含自己一个数字）
// 3 目标解是谁？LIS(n)？不对！DP数组并不是单调增！目标解：所有dp[i]的最大者！
// 4 转移方程？ 首先j<i ,if nums[j]<nums[i] 那么dp[i]=max(dp[i],dp[j]+1)
// 5 遍历方向？for外层循环以求解LIS(i)为目的，内层循环具体求解LIS(I)
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int sz=nums.size();
        if(sz<=1)return sz;
        vector<int> dp(sz,1);
        int res=0;
        for(int i=0;i<sz;i++){
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i])
                    dp[i]=max(dp[i],dp[j]+1);
            }
            // 到这里，正确得到dp[i]
            // 目标解 所有dp[i]的最大者！
            res=max(res,dp[i]);
        }
        return res;
    }
};
```





```js
var lengthOfLIS = function (nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    let res = 1; // LIS长度至少为1
    let dp = new Array(nums.length).fill(1);
    for (let i = 1; i < nums.length; i++) {
        for (let j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        res = Math.max(res, dp[i]);
    }
    return res;
};
```





### ~~376 最长摆动子序列的长度~~

摆动，离散子序列，最长长度

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427192557.png" alt="image-20210427192557700" style="zoom:80%;" />

sln **动态规划**，时间O(n^2)，空间O(n)
~~sln 贪心，时间O(n)，空间O(1)，遍历一遍~~



```bash
DP思路
	1 定义：dp[i]代表以i结尾的上升/下降的摆动子序列最长长度，dp[i][0]代表i是上升的情况下最长长度，dp[i][1]代表i是下降情况下的最长长度
	2 目标？以i结尾的LS的最长长度，可能上升可能下降
	3 初始化？dp[i][0] 或者dp[i][1] 最少包括自己，长度=1
	4 转移？
		求解dp[i][0] dp[i][1]的过程：
		i前面所有的数字j,
			if nums[j]<nums[i] #说明down -> up
				dp[i][0]=max(dp[i][0], dp[j][1]+1)
			else if nums[j]>nums[i] # up -> down
				dp[i][1]=max(dp[i][1], dp[j][0]+1)
	5 遍历顺序？已经说明了
```





```cpp
// DP
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        int sz=nums.size();
        if(sz<=1)return sz;
        vector<vector<int>> dp(sz,vector<int>(2,1));
        int res=1;
        for(int i=1;i<sz;i++){
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i]){
                    dp[i][0]=max(dp[i][0],dp[j][1]+1);
                }else if(nums[j]>nums[i]){
                    dp[i][1]=max(dp[i][1],dp[j][0]+1);
                }
            }
            res=max(res,max(dp[i][0],dp[i][1]));
        }
        return res;
    }
};
```





```js
// 贪心
var wiggleMaxLength = function (nums) {
    if (nums.length == 0) return 0;
    let res = 1;
    let curDiff = 0;
    let preDiff = 0;
    for (let i = 1; i < nums.length; i++){
        curDiff = nums[i] - nums[i - 1];
        if ((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) { // 只需要记录拐点，拐点数量+1就是最长波动序列的长度
            res++;
            preDiff = curDiff;
        }
    }
    return res;
};
```







### ~~1143 最长公共子序列 LCS~~

思路概述
可以暴力递归到动态规划



<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427193402.png" alt="image-20210427193402410" style="zoom:80%;" />

**时间O(mn)，空间O(mn)**
空间可以优化到O(n)上

暴力递归：

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427193637.png" alt="image-20210427193637793" style="zoom:80%;" />

LCS(m, n) S1[ 0 ... m ]和S2[ 0 ... n]的最长LCS的长度

S1[ m ] == S2[ n ] ：LCS(m, n) = 1+ LCS(m-1, n-1)
S1[ m ]  != S2[ n ] ：LCS(m, n) = max( LCS(m-1, n), LCS(m, n-1) )

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210427194015.png" alt="image-20210427194015368" style="zoom:80%;" />

改动态规划



```bash
# DP思路
	# dp[i][j]的定义！ 自己不容易想到！
	1 定义！！！： dp[i][j] 表示 str[0 ... i] str2[0...j]的最长公共长度
		# 单独的i 或者j 表示对应的字符串的覆盖范围
	2 目标 整个s1 与整个s2的LCS的长度，也就是 s1[0...m-1] s2[0...n-1] =dp[m-1][n-1]
	3 转移
		if s1[i]==s2[j]
			then dp[i][j]=1+dp[i-1][j-1]
			else dp[i][j]=max( dp[i-1][j], dp[i][j-1] )
	4 初始化： # 重要！
		dp[0][0] dp[0][1] dp[0][2] 代表的含义是啥？ ... LCS长度最多为1，因为子串1只有str[0]
	5 遍历方向
```

```cpp
// cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m=text1.size();
        int n=text2.size();
        vector<vector<int>> dp(m,vector<int>(n,0));
        bool flag=false;
        // 初始化方式！重要！
        // 比如当dp[0][3]代表的t1[0] == t2[3]的时候，此后的dp[0][i]都是1，因为dp[i][j]定义是t1[0... i] t2[0...j]的公共子序列长度
        for(int i=0;i<n;i++){
            if(text1[0]==text2[i]){
                flag=true;
            }
            if(flag){
                dp[0][i]=1;
            }
        }
        flag=false;
        // 初始化方式！重要！
        // 比如当dp[0][3]代表的t1[0] == t2[3]的时候，此后的dp[0][i]都是1，因为dp[i][j]定义是t1[0... i] t2[0...j]的公共子序列长度
        for(int i=0;i<m;i++){
            if(text1[i]==text2[0]){
                flag=true;
            }
            if(flag){
                dp[i][0]=1;
            }
        }
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                if(text1[i]==text2[j]){
                    dp[i][j]=dp[i-1][j-1]+1;
                }else{
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[m-1][n-1];
    }
};
```





```js
// JS
// 递归
var longestCommonSubsequence = function (text1, text2) {
    function LCS(i, j) {
        if (i < 0 || j < 0) {
            return 0;
        }
        if (text1[i] == text2[j]) {
            return LCS(i - 1, j - 1) + 1;
        }
        return Math.max(LCS(i - 1, j), LCS(i, j - 1));
    }
    return LCS(text1.length - 1, text2.length - 1);
};
// 改成DP
var longestCommonSubsequence = function (text1, text2) {
    let dp = new Array(text1.length);
    let leaf = false; // 一旦初始化边界出现1，后序全都是1
    for (let i = 0; i < dp.length; i++) {
        dp[i] = new Array(text2.length).fill(0);
    }
    for (let i = 0; i < text2.length; i++) { // 边界初始化
        if (leaf || text1[0] == text2[i]) {
            dp[0][i] = 1;
            leaf = true;
        }
    }
    leaf = false;
    for (let i = 0; i < text1.length; i++) { // 边界初始化
        if (leaf || text1[i] == text2[0]) {
            dp[i][0] = 1;
            leaf = true;
        }
    }
    for (let i = 1; i < dp.length; i++) {
        for (let j = 1; j < text2.length; j++) {
            if (text1[i] == text2[j]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[text1.length - 1][text2.length - 1];
};
```

同样是DP，稍微改动之后，就不需要这么麻烦的初始化边界

```js
var longestCommonSubsequence = function (text1, text2) {
    let m = text1.length;
    let n = text2.length;
    let dp = new Array(m + 1);
    for (let i = 0; i < m + 1; i++) {
        dp[i] = new Array(n + 1).fill(0);
    }
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (text1[i - 1] == text2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
};
```





### 略微改变定义，简化初始化

动态规划实现的时候，如果直接根据截图的定义，麻烦，**需要额外的初始化边界**
https://leetcode-cn.com/problems/longest-common-subsequence/solution/gong-shui-san-xie-zui-chang-gong-gong-zi-xq0h/
DP数组周围再补一圈，就能够避免复杂的初始化边界

初始化复杂的定义：`dp[m][n] 代表 s1[0~m] s2[0~n]的LCS的长度`
初始化简单的定义：`dp[m][n] 代表s1前m个字符 和s2前n个字符的LCS的长度`，既然是前x个字符的长度，那么前0个字符的LCS的长度自然=0

优化之后，**改变DP数组的定义**，后续的**初始化条件得到简化**，遍历终止条件，目标都有所改变

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m=text1.size();
        int n=text2.size();
        // dp[i][j]代表s1前i个字符和 s2前j个字符的LCS的长度
        // 目标？ s1 前m个字符 s2 前n个字符的LCS ，也就是dp[m][n]
        // 需要求解，从前1个字符开始，也就是dp[1][1]
        vector<vector<int>> dp (m+1,vector<int>(n+1,0));
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                if(text1[i-1]==text2[j-1]){
                    dp[i][j]=1+dp[i-1][j-1];
                }else{
                    dp[i][j]=max(dp[i][j-1],dp[i-1][j]);
                }
            }
        }
        return dp[m][n];
    }
};
```



___



## 打家劫舍

### ~~198 打家劫舍~~（一条街道）

被盗窃房屋不能相邻，返回最大价值



```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int>dp(n+1,0);
        dp[n-1]=nums[n-1];
        for(int i=n-2;i>=0;i--){
            dp[i]=max(dp[i+1],dp[i+2]+nums[i]);
        }
        return dp[0];
    }
// private:
//     // 类比背包问题，i是下标，j是背包容量，返回值代表价值，这里没有容量
//     int process(int i){
//         if(i==nums.size()){
//             return 0;
//         }
//         if(i==nums.size()-1){
//             return nums[i];
//         }
//         return max(process(i+1),process(i+2)+nums[i]);
//     }
};
```



需要处理好边界。

dp数组定义，dp[i]表示盗窃完nums[i]之后的最大价值（dp数组的定义也就是状态的定义，可以定义成考虑[0,...x]的房子，也可以定义成考虑[x...n-1]的房子）

转移方程，dp[i]=max(dp[i-1],dp[i-2]+nums[i]) 要么不盗取nums[i] 要么盗取nums[i]，放弃nums[i-1]

时间空间O(n)

```js
var rob = function (nums) {
    let n = nums.length;
    let dp = new Array(n).fill(0); // dp[i]表示盗窃完nums[i]之后的最大价值
    if (n == 0) return 0;
    if (n == 1) return nums[0];
    if (n == 2) return Math.max(nums[0], nums[1]);
    dp[0] = nums[0];
    dp[1] = Math.max(nums[0], nums[1]);
    for (let i = 2; i < n; i++){
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]); // 要么不盗取nums[i] 要么盗取nums[i]，放弃nums[i-1]
    }
    return dp[n - 1];
};
```



可以状态压缩，由于i 其实只依赖于 i - 1 和 i - 2 两个状态，因此我们其实不需要定义一个长度为 n 的 dp 数组，只要定义两个变量来存储 i - 1 和 i - 2

```js
var rob = function (nums) {
    let n = nums.length;
    let pre = 0, prepre = 0, cur = 0;
    for (let i = 0; i < n; i++){
        cur = Math.max(pre, prepre + nums[i]);
        prepre = pre;
        pre = cur;
    }
    return cur;
};
```



### q213 打家劫舍 2（一圈）

被盗窃房屋不能相邻，返回最大价值

房子循环相邻。也就是当nums.length>=2的时候，第一个房子和最后一个房子不能同时盗窃。

拆分成两个子问题，考虑第一个房子，放弃最后一个房子；考虑最后一个房子，放弃第一个房子。然后对子问题应用q198的解决方案。

```js
var rob = function (nums) {
    function helper(num) {
        let n = num.length;
        let pre = 0, prepre = 0, cur = 0;
        for (let i = 0; i < n; i++) {
            cur = Math.max(pre, prepre + num[i]);
            prepre = pre;
            pre = cur;
        }
        return cur;
    }
    if (nums.length == 0) return 0;
    if (nums.length == 1) return nums[0];
    return Math.max(helper(nums.slice(1)), helper(nums.slice(0, nums.length - 1)));
};
```



### q337 打家劫舍 3（二叉树）

被盗窃房屋不能相邻，返回最大价值

树形动态规划

有点难，不想看了暂时，**没完成**





## 买卖股票

### ~~121 买卖股票~~（一次）

只能**买卖一次**，求最大利润

仍然是暴力递归->DP

暴力思路，从idx开始，返回->能够赚的最大利润
每天更新历史最低价，然后看看利润

```cpp
class Solution {
public:
    int _maxrofit(vector<int>& prices) {
        int res=0;
        int _min=INT_MAX;
        for(int i=0;i<prices.size();i++){
            _min=min(_min,prices[i]);
            res=max(res,prices[i]-_min);
        }
        return res;
    }
// private:
//     int _min;
//     int _max;
//     int process(int i){
//         if(i==prices.size())return 0;
//         if(prices[i]<_min)
//         _min=prices[i];
//         _max=max(_max,prices[i]-_min);
//         return _max;
//     }
};
```



### ~~122 买卖股票2~~（无限次）

可以多次买卖，求最大利润

思路，贪心，能赚则赚，不断累加

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    let ret = 0;
    for (let i = 1; i < prices.length; i++) {
        if (prices[i] > prices[i - 1])
            ret += prices[i] - prices[i - 1];
    }
    return ret;
};
```





### 123 买卖股票3（最多2次）

难

只能买卖**最多两次**，求最大利润

贪心比较合适



### 188 买卖股票4（最多k次）

难

最多买卖k次，求最大利润



### 309 买卖股票（有冷却期）

1 卖出第二天无法买入
2 尽可能多次买卖，以获取最大利润

有点难，不想看了暂时，**没完成**





### 714 买卖股票（手续费）







## 整数分解+动态规划

### ~~343 整数拆分，乘积最大~~ 

>
>
>给一个整数，可以拆成若干整数的和，求最大的乘积是多少
>
>纯粹的暴力解法，加上内存而已，没有任何技巧
>
>定义 dp[i] 整数i拆分的最大乘积
>初始化...
>目标，dp[n]
>转移方程（状态依赖）：dp[i]=max{ m\*n, dp[m]\*n }
>
>~~如果循环想要减少一半，那么必须dp[i] = max{ m\*n, m\*dp(n) }，不能是max{ m\*n, dp[m]\*n }（没必要，不直观）~~
>
>~~https://leetcode-cn.com/problems/integer-break/solution/bao-li-sou-suo-ji-yi-hua-sou-suo-dong-tai-gui-hua-/~~



```cpp
class Solution {
public:
    int integerBreak(int n) {
        if(n<=1)return n;
        if(n==2)return 1;
        vector<int>dp(n+1,0);
        dp[1]=1;
        dp[2]=1;
        // 正向递归，没有任何技巧而言，纯粹加内存，思路就是暴力递归
        for(int i=3;i<=n;i++){
            for(int j=1;j<i;j++){ // 考虑例子分解数字9，必须要遍历一遍所有的分解情况，如果只遍历到n/2那么就会出错
                dp[i]=max(dp[i],max(dp[j]*(i-j),j*(i-j)));
            }
        }
        return dp[n];
    }
private:
    int process(int n){
        if(n<=1)return n;
        if(n==2)return 1;
        int res=0;
        for(int i=1;i<=n/2;i++){
            res=max(res,max(i*(n-i),process(i)*(n-i))); // 注意这里
        }
        return res;
    }
};
```





### 

> ~~给一个数字，如果只考虑拆分成两个整数的话，dp[n]=max{i\*(n-i)}~~
> ~~考虑到还可能继续拆分，dp[n]=max{i\*(n-i),i\*dp[n-i]}~~
> ~~为什么只考虑dp[n-i]，i的取值从1到n-1，为什么不能两个都是dp，比如dp[i]和dp[n-i]~~
> ~~因为：dp[i]\*dp[n-i]的乘积的结果，已经包含在了i\*dp[n-i]中：比如拆成m个数字，划分成1个(比如k)和其他的m-1个，这个时候的乘积就等同于k\*dp[n-k]~~
> ~~所以，dp[i]=max{i\*j,i\*dp[j]}~~
>
> ~~另外需要注意dp初值~~

~~采用动态规划，空间O(n)，时间O(n^2)~~

```js
// dp[i]表示整数i，拆分成2个或者若干整数之后的最大乘积
// 转移方程，dp[i]=max{dp[i-1]*dp[1]}
var integerBreak = function (n) {
    let dp = new Array(n + 1).fill(0);
    dp[1] = 1, dp[2] = 1;
    for (let i = 2; i <= n; i++) {
        for (let j = 1; j < i; j++) {
            dp[i] = Math.max(dp[i], j * (i - j), j * dp[i - j]);
        }
    }
    return dp[n];
};
```



>
>
>~~数学角度给出的解答，也可以理解成贪心算法~~
>~~[参考自](https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-shu-xue-fang-fa-han-wan-zheng-t/)~~
>~~特殊情况特殊处理，其他情况分类讨论总结出函数的表达式即可。~~
>~~时间O(1)，空间O(1)~~



```js
var integerBreak = function (n) {
    if (n <= 3) return n - 1;
    let p = Math.floor(n / 3);
    let q = n % 3;
    if (q == 2) return 2 * 3 ** p;
    else if (q == 1) return 4 * 3 ** (p - 1);
    else return 3 ** p;
};
```







### ~~279  完全平方数~~ 

>
>
>给一个整数，可以拆分成若干完全平方数的和，求，最少可以几个完全平方数的和
>
>两种思路
>1 先列举拆分情况，再判断每个拆分情况的完全平方数的个数，时间O(n^2)，超时
>（  dp[i] = min {  j 是完全平方数? 1: dp[j] + (i-j)是完全平方数? 1: dp[i-j]     }
>2 改变**枚举策略**，**枚举平方数**，时间O(nlogn)
>
>定义，dp[i] 数字i可以被拆分成完全平方数的最少个数
>初始化...
>目标...
>转移，dp[i] = min { 1+(isSquare(i-j\*j)?1:dp[i-j*j]) }



```bash
# 列出所有拆分情况，逐一判断是不是完全平方数
int process(n)
	n如果是完全平方数， return 1
	res =INT_MAX
	for i=1;i<n;i++
		res=min( res, (isSquare(i)?1:process(i))+(isSquare(n-i)?1:process(n-i)) )
	return res
```



内层循环，改变枚举方式之后，时间n*logn，勉强能过

```cpp
class Solution {
public:
    int numSquares(int n) {
        if(n<=3)return n;
        vector<int> dp(n+1,INT_MAX);
        dp[1]=1;
        dp[2]=2;
        dp[3]=3;
        for(int i=4;i<=n;i++){
            if(isSquare(i)){
                dp[i]=1;
                continue;
            }
            // 枚举方式改动了一下，时间n*logn
            for(int j=1;j*j<=i;j++){
                dp[i]=min(dp[i],1+(isSquare(i-j*j)?1:dp[i-j*j]));
            }
            // 纯暴力，时间n^2，超时
            // for(int j=1;j<=i/2;j++){
            //     dp[i]=min(dp[i], (isSquare(j)?1:dp[j]) + (isSquare(i-j)?1:dp[i-j]));
            // }
        }
        for(int i=1;i<=n;i++){
            printf("%d is %d\n",i,dp[i]);
        }
        return dp[n];
    }
private:
    bool isSquare(int n){
        int res=sqrt(n);
        return res*res == n;
    }
    int process(int n){
        if(n<=3)return n;
        if(sqrt(n)*sqrt(n)==n)return 1;
        int res=INT_MAX;
        for(int i=1;i<n;i++){
            res=min(res, process(i)+process(n-i));
        }
        return res;
    }
};
```







### ~~96 不同的二叉搜索树的数量~~

```js
/**
 * 1到n个整数，对应的二叉搜索树的个数有多少个
 * dp[i]定义为1到i的整数对应的BST的个数
 * dp[1]，也就是1对应的BST，1个
 * dp[2]，1,2对应的BST，2个
 * dp[3]，1-3对应的BST，5个
 * dp[3]，包括，以整数1为根的BST的个数+以2为根的BST+以3为根的BST
 * 以1为根的BST，左子树包含0个节点，右子树包含2个节点
 * 以2为根的BST，左子树包含1个节点，右子树包含1个节点
 * 以3为根的BST，左子树包含2个节点，右子树包含0个节点
 * 实际上dp[i]的定义可以理解为包含了n个节点的BST的个数
 * 因此，
 * 以1为根的BST，左子树包含0个节点，右子树包含2个节点，=dp[0]*dp[2]
 * 以2为根的BST，左子树包含1个节点，右子树包含1个节点, =dp[1]*dp[1]
 * 以3为根的BST，左子树包含2个节点，右子树包含0个节点, =dp[2]*dp[0]
 * 从而dp[3]=dp[0]*dp[2]+dp[1]*dp[1]+dp[2]*dp[0]
 * 确定递推公式：dp[n]=sum(dp[0]*dp[n-1]+...+dp[n-1]*dp[0])，也就是dp[n]=sum(dp[i][n-1-i]),i从0到n-1
 * 举例，画图，分析得到递归公式，遍历顺序和初始化
 */
var numTrees = function (n) {
    let dp = new Array(n + 1).fill(0);
    dp[0] = 1, dp[1] = 1;
    for (let i = 2; i <= n; i++) {
        for (let j = 0; j < i; j++) {
            dp[i] += dp[j] * dp[i - 1 - j];
        }
    }
    return dp[n];
};
```



### 91 解析数字字符串

这道题我一开始看到的思路是回溯深搜，分割字符串，达到一个叶子节点就进行判断数据是否合法，合法则cnt++

回溯算法我没有实现呢，不过我看评论说会有很多重复子问题，也就是说最好采用dp



[dp的思路参考自](https://leetcode-cn.com/problems/decode-ways/solution/c-wo-ren-wei-hen-jian-dan-zhi-guan-de-jie-fa-by-pr/)

这道题题目中有特殊例子，比如s包含前导0，比如01,02这种字符串，以及0这种字符串

关键是搞清楚dp[i-1] dp[i-2]所代表的分割方案是啥

什么样的两位数能够有两种分割方案，什么样的只有一种？10,20只有一种，10-26的其他数字有两种，26之外的数字只有一种（前提是，不能是30,40这种）

**分割方案该怎么表示**

**一种分割方案的话，dp[i]=dp[i-2]**

**两种分割方案，dp[i]=dp[i-2]+dp[i-1]，但是我不理解**

包含0的字符串，只能是10,20可以，其他30,40都不行，单独的0不行，01,02等等也不行



下面这个过程也是参考着那个题解的评论来写的，**完全不会这道题**

```js
var numDecodings = function(s) {
    if (s[0] == '0') return 0;
    let n = s.length;
    let dp = new Array(n + 1).fill(1);
    for (let i = 2; i <= n; i++){
        if (s[i - 1] == '0') {
            if (s[i - 2] == '1' || s[i - 2] == '2') // 10 20 只有一种方案 组成成一个数字
                dp[i] = dp[i - 2];
            else return 0; // 30 40 等等 没有方案
        }
        else if (s[i - 2] == '1' || (s[i - 2] == '2' && s[i - 1] <= '6')) { // 11-19 21-26 有两种方案
            dp[i] = dp[i - 2] + dp[i - 1];
        } else {
            dp[i] = dp[i - 1]; // 26之后的数字，只能分割成两个个位数
        }
    }
    return dp[n];
};
```







## 自己发散的题目

[参考自](https://leetcode-cn.com/problems/unique-paths-ii/solution/bu-tong-lu-jing-ii-by-leetcode-solution-2/)

回顾这道题，其实这类动态规划的题目在题库中也出现过多次，例如「221. 最大正方形」、「1162. 地图分析」等。他们都以二维坐标作为状态，大多数都可以使用滚动数组进行优化。如果我们熟悉这类问题，可以一眼看出这是一个动态规划问题。



### q221 最大正方形

时间空间O(m*n)，可以进行状态压缩，但是自己没弄出来。

[参考自](https://leetcode-cn.com/problems/maximal-square/solution/zui-da-zheng-fang-xing-by-leetcode-solution/)

用`dp(i, j) `表示以 `(i, j)`为右下角，且只包含 11 的正方形的边长最大值。如果我们能计算出所有 `dp(i, j)`的值，那么其中的最大值即为矩阵中只包含 11 的正方形的边长最大值，其平方即为最大正方形的面积

```js
var maximalSquare = function (matrix) {
    let row = matrix.length;
    if (row == 0) return 0;
    let col = matrix[0].length;
    if (col == 0) return 0;
    let dp = new Array(row);
    for (let i = 0; i < row; i++)
        dp[i] = new Array(col).fill(0);
    let res = 0;
    for (let i = 0; i < row; i++) {
        for (let j = 0; j < col; j++) {
            if (matrix[i][j] == 1) {
                if (i == 0 || j == 0) // 初始化左边界 上边界
                    dp[i][j] = 1;
                else
                    dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]); // 相当于 &&左上&&左&&上 木桶短板理论
                res = Math.max(res, dp[i][j]); // 记录最大边长
            }
        }
    }
    return res * res;
};
```



### q1277 统计全为1的正方形子矩阵

奇妙，边长刚好代表了正方形的个数？是的。奇妙

时间空间O(m*n)，也可以状态压缩

```js
var countSquares = function (matrix) {
    let row = matrix.length;
    if (row == 0) return 0;
    let col = matrix[0].length;
    if (col == 0) return 0;
    let dp = new Array(row);
    for (let i = 0; i < row; i++)
        dp[i] = new Array(col).fill(0);
    let res = 0;
    for (let i = 0; i < row; i++) {
        for (let j = 0; j < col; j++) {
            if (matrix[i][j] == 1) {
                if (i == 0 || j == 0)
                    dp[i][j] = 1;
                else
                    dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]);
                res += dp[i][j]; // 边长刚好就代表了正方形的个数？
            }
        }
    }
    return res;
};
```



### q1162 地图分析

难度中等，但是好像比较复杂，先跳过

**没完成**



```js
var maxDistance = function (grid) {
    let row = grid.length;
    if (row == 0) return 0;
    let col = grid[0].length;
    if (col == 0) return 0;
    let dp = new Array(row);
    for (let i = 0; i < row; i++)
        dp[i] = new Array(col).fill(0);
    let res = 0;
    for (let i = 0; i < row; i++) {
        for (let j = 0; j < col; j++) {
            if (grid[i][j] == 0) {
                if (i == 0 || j == 0)
                    dp[i][j] = 1;
                else
                    dp[i][j] = 1 + Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]);
                res = Math.max(res, ...);
            }
        }
    }
    return res;
};
```




___



___

## 动态规划几种问题的小结

>
>
>[参考](https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/)
>
>**常见的背包问题有1、组合问题。2、True、False问题。3、最大最小问题。**
>
>```bash
># 1、组合问题：
>377. 组合总和 Ⅳ
>494. 目标和
>518. 零钱兑换 II
># 2、True、False问题：
>139. 单词拆分
>416. 分割等和子集
># 3、最大最小问题：
>474. 一和零
>322. 零钱兑换
>```
>
>
>
>组合问题公式
>
>```
>dp[i] += dp[i-num]
>```
>
>
>
>True、False问题公式
>
>```bash
>dp[i] = dp[i] or dp[i-num]
>```
>
>
>
>最大最小问题公式
>
>```bash
>dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1)
>```
>
>
>
>以上三组公式是解决对应问题的核心公式。
>
>当然拿到问题后，需要做到以下几个步骤：
>1.分析是否为背包问题。
>2.是以上三种背包问题中的哪一种。
>3.是0-1背包问题还是完全背包问题。也就是题目给的nums数组中的元素是否可以重复使用。
>4.如果是组合问题，是否需要考虑元素之间的顺序。需要考虑顺序有顺序的解法，不需要考虑顺序又有对应的解法。
>
>接下来讲一下背包问题的判定
>背包问题具备的特征：给定一个target，target可以是数字也可以是字符串，再给定一个数组nums，nums中装的可能是数字，也可能是字符串，问：能否使用nums中的元素做各种排列组合得到target。
>
>背包问题技巧：
>1.如果是0-1背包，即数组中的元素不可重复使用，nums放在外循环，target在内循环，且内循环倒序；
>
>```python
>for num in nums:
>    for i in range(target, nums-1, -1):
>```
>
>
>
>
>
>2.如果是完全背包，即数组中的元素可重复使用，nums放在外循环，target在内循环。且内循环正序。
>
>```python
>for num in nums:
>    for i in range(nums, target+1):
>```
>
>
>
>
>
>3.如果组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环。
>
>```python
>for i in range(1, target+1):
>    for num in nums:
>```
>
>
>
>```python
>class Solution:
>    def combinationSum4(self, nums: List[int], target: int) -> int:
>        if not nums:
>            return 0
>        dp = [0] * (target+1)
>        dp[0] = 1
>        for i in range(1,target+1):
>            for num in nums:
>                if i >= num:
>                    dp[i] += dp[i-num]
>        return dp[target]
>```
>
>



___

## 组合数量问题



### 377 组合总数



>
>
> 这还能用动规？？？
>
>给你一个**由 不同 整数组成的数组** nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。
>
>题目数据保证答案符合 32 位整数范围。

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```



回顾题目，数组中，数字不相同，不同的序列视作不同的组合，每个数字可以使用无数次
题目实际上求解的是给定target的有多少种排列

看评论区

sln 



```js
// 错误的sln，这个sln求解的是种类数量，由于nums不包含重复的数字，因此求解的是种类数量
// 比如[1,1,1,1] [1,1,2] [1,3] [2,2]
// 这里求解的实际上是combination的数量，题目要求的是arrangement的刷领
var combinationSum4 = function (nums, target) {
    if (nums == null || nums.length == 0 || target == 0) {
        return 0;
    }
    let dp = new Array(target + 1).fill(0);
    dp[target] = 1;
    for (let i = nums.length - 1; i >= 0; i--) {
        for (let j = 0; j <= target; j++) {
            for (let k = 0; k * nums[i] + j <= target; k++) {
                dp[j] += dp[k * nums[i] + j];
            }
        }
    }
    return dp[0];
};

function rec(i, j) {
    if (i == nums.length) {
        return j == target ? 1 : 0;
    }
    let res = 0;
    for (let k = 0; k * nums[i] + j <= target; k++) {
        res += rec(i + 1, k * nums[i] + j);
    }
    return res;
}
```



### ~~494 目标和~~

>
>
>一个整数数组（非负数），求所有方案的数量
>每个数字可以+或者-，最终结果=目标值的方案的数量
>
>回溯法很容易解决，关键是怎么用动态规划解决？
>回溯法，时间2^n，空间O(n)
>
>动态规划解法如下
>
>关键是思路，题目给定的，X+Y=SUM X-Y=num ，也就是说，数组划分成了两部分，两部分之和是固定的，X-Y=目标值
>那么问题转化成，求出来X即可，X=(SUM+num)/2,
>**进一步转化成，从nums数组中挑选数字，累加和=固定值，求所有的方案数**
>动态规划，**时间n*sum**，空间(n\*sum)，其中n是数组的长度

```cpp
// 动态规划
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum=0;
        for(int num:nums){
            sum+=num;
        }
        target=sum+target;
        if((target&1))return 0;
        target=target/2;
        int sz=nums.size();
        // 问题转化成从idx=开始，累加和=0，有多少种方案累加和=target
        vector<vector<int>>dp(sz+1,vector<int>(target+1,0));
        // 初始化
        for(int i=0;i<dp.size();i++){
            dp[i][target]=1;
        }
        for(int i=sz-1;i>=0;i--){
            for(int j=0;j<=target;j++){ 
                if(j+nums[i]>target){
                    dp[i][j]=dp[i+1][j];
                }else{
                    dp[i][j]=dp[i+1][j]+dp[i+1][j+nums[i]];
                }
            }  
        }
        return dp[0][0];
    }
    // praivet:
    // // 从idx开始，当前累加和=cursum，累加和=target的方案数
    // // 如果nums[idx]+cursum>target，
    // //    那么return process(idx+1,cursum)，代表含义，方案数=从idx+1,cursum的方案数，也就是当前idx对应的数字不要
    // // 如果<=
    // //      process(idx+1,cursum) + process(idx+1,cursum+nums[idx]);
    
    // int process(int idx,int cursum){
    //     if(idx==sz){
    //         return cursum==target?1:0;
    //     }
    //     if(cursum+nums[idx]>target)
    //     return process(idx+1,cursum);
    //     return process(idx+1,cursum)+process(idx+1,cursum+nums[idx]);
    // }
};
```





```cpp
// 回溯法，解决起来很容易
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        this->target=target;
        dfs(nums,0,0);
        return total;
    }
private:
    int total=0;
    int target=0;
    void dfs(vector<int>&nums, int idx, int curSum){
        if(idx==nums.size()){
            if(curSum==target){
                total++;
            }
            return;
        }
        dfs(nums,idx+1,curSum+nums[idx]);
        dfs(nums,idx+1,curSum-nums[idx]);
    }
};
```



### 518 零钱兑换2





___



## True False问题

### 139 单词拆分 word split





### ~~416 划分等和子集~~

>
>
>给定一个**只包含正整数**的**非空**数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。
>
>sln-1 
>sln-2 问题转化成，背包问题，从n个物品中选取若干物品，**填满sum/2的背包（背包完全填满）**
>
>如果DP想状态压缩，DP压缩的时候，容易出现数据覆盖，进行DP压缩之前，先根据二维DP搞清楚运算的方向（状态压缩的时候，一定要避免数据覆盖！）

```bash
1. 定义，dp[i][j] 从idx=i开始，j表示当前累加和,的情况下，能够累加出target
2  目标，dp[0][0] 从idx=0开始，初始累加和=0，能否累加出target（dp[0][0]就是原问题）
3  初始化，idx=sz的时候，num可以选取，false
4 转移，dp[i][j] j+nums[i]>target
5 遍历方向，略过
```



```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        if(nums.size()==0){
            return true;
        }
        int sum=0;
        for(int i=0;i<nums.size();i++){
            sum+=nums[i];
        }
        if(sum%2==1)return false;
        target=sum/2;
        int m=nums.size();
        vector<bool>dp(target+1,false);
        dp[target]=true;
        for(int i=m-2;i>=0;i--){
            for(int j=0;j<=target-1;j++){ // 一定要注意这里的运算方向，和二维DP不同，或者说二维DP的运算方向，J是可以任意方向遍历的！而一维DP，只能按照绝对正确的逻辑方向进行遍历
                dp[j]=dp[j]||(nums[i]+j>target?false:dp[j+nums[i]]);
            }
            // for(int i=0;i<dp.size();i++){
            //     cout<<dp[i]<<" ";
            // }
            // cout<<endl;
        }
        return dp[0];
    }
```





___

## 最大最小问题



### 难！！！

### 322 零钱兑换（完全背包问题）

>
>
>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以**凑成总金额所需的最少的硬币个数**。如果没有任何一种硬币组合能组成总金额，返回 -1。
>
>你可以认为每种硬币的数量是无限的。
>
>sln 递归改动规，时间O(mn)，空间O(n)

>
>
>**朴素但是超时的做法**
>
>暴力递归改动态规划， 三重循环解决完全背包问题，第三层循环遍历coins[i]的可枚举的数量
>整体时间复杂度O(n^3)（大致）
>
>完全背包问题，
>完全背包的讲解，[参考](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-bei-bao-wen-ti-zhan-zai-3265/)
>
><img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210519212332.png" alt="img" style="zoom:80%;" />



```cpp

class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n=coins.size();
        vector<vector<long>>dp(n+1,vector<long>(amount+1,INT_MAX));
        dp[n][amount]=0;
        for(int i=n-1;i>=0;i--){
            for(int j=amount;j>=0;j--){
                for(int k=0;static_cast<double>(j)+coins[i]*k<=amount;k++){
                    if(dp[i+1][j+k*coins[i]]!=INT_MAX){
                        dp[i][j]=min(dp[i][j],k+dp[i+1][j+coins[i]*k]);
                    }
                }
            }
        }
        return dp[0][0]==INT_MAX?-1:dp[0][0];
    }
// private:
//     // 从idx下标开始，已经累加了amount金额，看看能不能累加出target
//     // 如果能累加出来，那么就返回金币数量；累加不出来，返回INT_MAX
//     int process(int idx, int amount){
//         if(idx==coins.size()){
//             return amount==target?0:INT_MAX;
//         }
//         int res=INT_MAX;
//         for(int i=0;coins[idx]*i+amount<=target;i++){
//             res=min(res,i+process(idx+1,amount+coins[idx]*i));
//         }
//         return res;
//     }
};
```





```js
var coinChange = function (coins, amount) {
    if (amount == 0) return 0;
    let dp = new Array(amount + 1).fill(Number.MAX_SAFE_INTEGER);
    dp[0] = 0;
    for (let i = coins.length - 1; i >= 0; i--) {
        for (let j = 0; j <= amount; j++) {
            if (j - coins[i] >= 0) {
                dp[j] = Math.min(dp[j], 1 + dp[j - coins[i]]);
            }
        }
    }
    return dp[amount] == Number.MAX_SAFE_INTEGER ? -1 : dp[amount];
};

// idx from 0 to coins.length
// aim from 0 to amount
// dp[i][j]=min(dp[i][j],k+dp[i+1][j-k*coins[i]])
// dp[0][amount]
function rec(idx, aim) {
    if (idx == end) {
        return aim == 0 ? 0 : MAX;
    }
    let res = MAX;
    for (let i = 0; i * coins[idx] <= aim; i++) {
        res = min(res, i + rec(idx + 1, aim - i * coins[idx]))
    }
    return res;
}
```



### ~~474 两个限制条件的01背包问题~~

>
>
>```bash
>1 定义 dp[i][j][k] 从下标i的iterm开始，已经累加了j个字符0，k个字符1，这种情况下能够能够选取的最大iterm数量
>2 目标 dp[0][0][0] 从下标为0的开始
>3 初始化 dp[i][j][k] #重要！如何形象 直观地理解初始化？？？
>4 转移， countZeroOnes(string)=>得到str[i]的0的数量，1的数量
>		if j+mid[0] <=m && k+mid[1]<=n # 可以容纳得下 iterm-i
>			dp[i][j][k]= min( dp[i+1][j][k], dp[i+1][j+mid[0]][k+mid[1]] ) # 选与不选iterm-i
>		else dp[i][j][k]=dp[i+1][j][k]
>5 遍历方向 
>	从右下角到左上角 #三层循环 循环的开始和结束，怎么直接理解？？？
>```
>
>



```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        int p=strs.size();
        vector<vector<vector<int>>> dp (p+1, vector<vector<int>>(m+1,vector<int>(n+1,0)));
        for(int i=p-1;i>=0;i--){
            // 这里返回临时vector，返回vector&会报错，该怎么处理呢？
            vector<int> mid=countZeroOnes(strs[i]);
            for(int j=0;j<=m;j++){
                for(int k=0;k<=n;k++){
                    if(j+mid[0]<=m&&k+mid[1]<=n){
                        dp[i][j][k]=max(dp[i+1][j][k],1+dp[i+1][j+mid[0]][k+mid[1]]);
                    }else{
                        dp[i][j][k]=dp[i+1][j][k];
                    }
                }
            }
        }
        return dp[0][0][0];
    }
private:
    vector<int> countZeroOnes(const string& s){
        vector<int>res(2,0);
        for(const char& ch:s){
            if(ch=='1'){
                res[1]++;
            }else{
                res[0]++;
            }
        }
        return res;
    }
};
```







## 一个状态依赖于多个状态

### 322 零钱兑换（难！）

不能用贪心的思路做，用动规，最优子结构，换amount金额用的最少的硬币数量=换amount-coin用的硬币数量+1。完善初始状态即可。

[思路参考](https://leetcode-cn.com/problems/coin-change/solution/dong-tai-gui-hua-shi-yong-wan-quan-bei-bao-wen-ti-/)

```js
// 动规
// dp[i]含义，兑换金额为i，最少需要的硬币数量
// 转移方程，dp[i]=min{dp[i-coin]+1}
// 初始状态dp[0]=0，兑换0元，需要硬币0个
// 最终状态dp[amount]，一共兑换amount金额
var coinChange = function (coins, amount) {
    let dp = new Array(amount + 1).fill(amount + 1);
    dp[0] = 0;
    for (let i = 1; i <= amount; i++){
        for (let coin of coins) {
            if (i >= coin && dp[i - coin] != amount + 1)
                dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
        }
    }
    if (dp[amount] == amount + 1) return -1;
    return dp[amount];
};
```



### 518 零钱兑换2



### 121 买卖股票的最佳时机

下面几道股票题目都[参考自微信公众号文章](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247484509&idx=1&sn=21ace57f19d996d46e82bd7d806a2e3c&source=41#wechat_redirect)



只能买入卖出一次。

怎么确定什么时间买？什么时间卖？

穷举所有的可能，O(n^2)，第x天买，第y天卖

固定买入时间，内层for循环是为了找最佳的卖出时间。内层for可以被优化掉，新添加数据的时候，可以用O(1)的时间，用已有的最值推到最新的最值，而不必O(n)遍历一遍才获得最值。

```js
var maxProfit = function (prices) {
    let n = prices.length;
    let res = 0;
    for (let i = 0; i < n - 1; i++) {
        for (let j = i + 1; j < n; j++) {
            res = Math.max(res, prices[j] - prices[i]);
        }
    }
    return res;
};
```



关键不在于最大值还是最小值，而是数字的添加和减少。添加新数时，可以根据已有最值，推导出新的最值；而减少数字时，不一定能直接推出新的最值，不得不重新遍历。内层for循环

```js
var maxProfit = function (prices) {
    let res = 0;
    let curMin = prices[0];
    for (let i = 0; i < prices.length; i++){
        curMin = Math.min(curMin, prices[i]);
        res = Math.max(res, prices[i] - curMin);
    }
    return res;
}
```



关键就在于找到所有可能的「状态」，然后想想怎么更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？



具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？



__

## 背包问题

0-1背包：每个物品最多选择1次
完全背包：每个物品可以无限次选择

### 01背包模板

>
>
>终极写法：
>转移方程：
>
>`f[i][j]=max{ f[i-1][j], f[i-1][j-w[i]]+v[i] }`
>优化： 
>`f[i][j]=max{  }`
>
>```cpp
>// dp[i][j] 集合：前i个物品，背包容量j的方案 属性：最大价值
>for(int i=1;i<=n;i++)
>   for(int j=m;j>=v[i];j--) // 逆序
>         f[j]=max(f[j],f[j-v[i]]+w[i]);
>   ```
>01背包原始写法：
>
>```cpp
>for(int i=1;i<=n;i++)
>for(int j=0;j<=m;j++)
>  if(w[i]<=j) // 第i个商品容量<=背包
>         dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);
>       else // 商品容量>背包，1个也装不下
>           dp[i][j]=dp[i-1][j];
>     ```
>     
>     尝试压缩，但是错误的写法：
>   错误的根源，遍历方向出错，新数据覆盖旧数据
>
>```cpp
>for(int i=1;i<=n;i++)
>for(int j=w[i];j<=m;j++) // 空间优化，但是遍历方向错误，数据出现覆盖！
>  dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
>```
>



### 完全背包和01背包转移方程的区别

<img src="https://yszhou.oss-cn-beijing.aliyuncs.com/img/20210520145846.png" alt="image-20210520145839114" style="zoom:80%;" />

|              | 01背包                                          | 完全背包                                      |
| ------------ | ----------------------------------------------- | --------------------------------------------- |
|              | `f[i][j]=max {f[i-1][j], f[i-1][j-w[i]]+v[i] }` | `f[i][j]=max{ f[i-1][j], f[i][j-w[i]]+v[i] }` |
| 一维转移方程 | `f[j]=max{ f[j], f[j-w[i]]+v[i] }`              | `f[j]=max{ f[j], f[j-w[i]] + v[i] }`          |
| 一维遍历方向 | i正序，从1到m，j逆序（避免数据覆盖）            | i正序，j正序                                  |

如果**二维DP，那么j的循环方向无所谓，不会发生数据覆盖**





### 完全背包模板

>
>
>最终版：
>
>
>```cpp
>//一维版本
>for(int i=1;i<=n;i++)
>    for(int j=w[i];j<=m;j++) // 正序
>     	f[j]=max(f[j],f[j-w[i]]+v[i]);   
>    ```
>
>
>朴素方法不再说，三重循环，第三层循环枚举商品v[i]可选择的数量
>
>完全背包转移方程：
>`f[i][j]=max{ f[i-1][j], f[i][j-w[i]]+v[i] }`
>一维版本：
>`f[j]= max{ f[j], f[j-w[i]]+v[i] }`
>
>```cpp
>// 二维版本
>for(int i=1;i<=n;i++)
>for(int j=0;j<=m;j++)
>    f[i][j]=f[i-1][j];
>        if(j>=w[i])
>             f[i][j]=max(f[i][j],f[i][j-w[i]]+v[i]);
>     ```
>     



### 最长上升子序列

>
>
>状态表示，集合{以第i个字符结尾的上升子串 }， 属性（最长长度）
>方程，`f[i]=max{ 1+f[j] }, j<i&& s[j]<s[i]`
>
>
>```cpp
>for(int i=1;i<=n;i++)f[i]=1;
>
>for(int i=2;i<=n;i++)
>for(int j=1;j<i;j++)
>if(w[i]>w[j])f[i]=max(f[i],f[j]+1);
>int res=-INF;
>for(int i=1;i<=n;i++)res=max(res,f[i]);
>```
>
>



### 最长公共子序列

>
>
>状态表示，集合{ 串1中1~i的范围，串2中1~j的范围，公共子序列 }，属性（最长长度）
>状态计算，
>
>```cpp
>if s1[i]==s2[j]
>	f[i][j]=f[i-1][j-1]+1
>else f[i][j]=max(f[i-1][j], f[i][j-1]) + 1
>```
>
>
>
>```cpp
>    for(int i=1;i<=n;i++)
>    for(int j=1;j<=m;j++)
>    if(s1[i]==s2[j])
>    f[i][j]=1+f[i-1][j-1];
>    else
>    f[i][j]=max(f[i-1][j],f[i][j-1]);
>
>    cout<<f[n][m]<<endl;
>```
>
>



### 最短编辑距离

>
>
>a为了成为b，可以改变一个字母，可以增加一个字母，可以删除一个字母
>
>状态表示，`f[i][j]` 串1的前i个字母变成串2的前j个字母，需要的操作数量
>状态计算，
>
>```
>f[i][j]=min { f[i][j-1]+1,  # a需要增加一个字母
>			f[i-1][j]+1 } # a[1~i-1]和b[1~j]匹配，这时候a需要删除最后一个字母
>if a[i]==b[i] 
>	then f[i][j]=min{ f[i][j], f[i-1][j-1] }
>	else f[i][j]=min{ f[i][j], f[i-1][j-1] +1 }
>```
>
>
>
>```
># 初始化
>for i=1~m f[0][i]=i; # 串a前0个字母（也就是空串）需要添加i个字母，才能变成串b的前i个字母
>for i=1~n f[i][0]=i; # 串a前i个字母，需要删除i次，才能变成串b的前0个字母（空串）
>```
>
>
>
>目标解，`f[n][m]` 串1的前n个字母变成串2的前m个字母，需要的操作数（整个串1变成串2需要的操作数）
>
>```cpp
>    for(int i=0;i<=n;i++)f[i][0]=i; // 初始化
>    for(int i=0;i<=m;i++)f[0][i]=i; // 初始化
>    for(int i=1;i<=n;i++)
>    for(int j=1;j<=m;j++)
>    {
>        f[i][j]=min(f[i-1][j]+1, // a需要删除最后一个字母s1[i]
>                    f[i][j-1]+1); // a需要增加一个字母s2[j]
>        if(s1[i]==s2[j])f[i][j]=min(f[i][j],f[i-1][j-1]); // 如果最后一个字母相同，那么不需要尝试改动
>        else f[i][j]=min(f[i][j],f[i-1][j-1]+1); // 如果最后一个字母不相同，那么需要尝试改动
>     }
>    
>    cout<<f[n][m]<<endl;
>    ```
>
>



### 编辑距离

>
>
>```cpp
>#include <iostream>
>#include <cstring>
>#include <algorithm>
>
>using namespace std;
>
>const int N=1010;
>const int M=15;
>char str[N][M];
>int f[N][N];
>const int INF=1e9;
>
>int edit_distance(char s1[],char s2[])
>{
>    int la=strlen(s1+1);
>    int lb=strlen(s2+1);
>    for(int i=0;i<=la;i++)f[i][0]=i;
>    for(int i=0;i<=lb;i++)f[0][i]=i;
>    for(int i=1;i<=la;i++)
>    for(int j=1;j<=lb;j++)
>    {
>        f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1);
>        f[i][j]=min(f[i][j], f[i-1][j-1]+(s1[i]==s2[j]?0:1));
>    }
>    return f[la][lb];
>}
>
>int main()
>{
>    int n,m;
>    cin>>n>>m;
>    for(int i=0;i<n;i++) scanf("%s",str[i]+1);
>    
>    while(m--){
>        char s[M];
>        int limit;
>        scanf("%s%d",s+1,&limit);
>        
>        int res=0;
>        for(int i=0;i<n;i++)
>            if(edit_distance(str[i],s)<=limit)
>                res++;
>        cout<<res<<endl;
>    }
>    return 0;
>}
>```
>
>



### 前面求的都是最值，下面求的都是个数

### 整数划分

>
>
>（不考虑顺序，求方案总数）
>
>**完全背包角度求解**
>
>状态表示，`f[i][j]`表示从1~i一共i类数中，挑选数字，使得总和=j的方案。属性，方案的总数量
>状态计算，
>
>```
>f[i][j]		= f[i-1][j] + f[i-1][j-i] + f[i-1][j-2*i] + ... + f[i-1][j-s*i]
>f[i][j-i]	= 			f[i-1][j-i]   + f[i-1][j-2*i]+ ... + f[i-1][j-s*i]
>=>f[i][j]= f[i-1][j]+f[i][j-i]
>```
>
>```cpp
>// 压缩空间
>    f[0]=1;
>    for(int i=1;i<=n;i++)
>    for(int j=i;j<=n;j++)
>    if(j>=i)f[j]=(f[j]+f[j-i])%mod;
>    cout<<f[n]<<endl;
>```
>
>二维
>
>初始化
>
>```cpp
>    // f[i][j] 当J=0，代表挑选，使得目标和=0，因此f[i][0]=1
>    // f[i][j] 当i=1，任何目标和，方案数都=1，f[1][i]=1
>    for(int i=0;i<=n;i++){
>        f[i][0]=1;
>        f[1][i]=1;
>    }
>    // 上述循环可以简化成f[0][0]=1
>    for(int i=1;i<=n;i++)
>    for(int j=0;j<=n;j++){
>        f[i][j]=f[i-1][j];
>        if(j>=i)f[i][j]=(f[i-1][j]+f[i][j-i])%mod;
>    }
>    cout<<f[n][n]<<endl;
>```
>
>







## 线性DP



数字三角形（最小路径和

>
>循环体内不统一的解法
>
>```cpp
>    for(int i=2;i<=n;i++)
>        for(int j=1;j<=i;j++)
>            if(j==1)
>            f[i][j]+=f[i-1][j];
>            else if(j==i)
>            f[i][j]+=f[i-1][j-1];
>            else 
>            f[i][j]=max(f[i-1][j],f[i-1][j-1])+f[i][j];
>     ```
>    
>循环体内不进行判断的解法：
>
>```cpp
>for(int j=0;j<=i+1;j++)f[i][j]=-INF; // 边界初始化为-无穷，循环体内部的逻辑被简化了，没有区分考虑每一行的第一列和最后一列，每一行的第一列因此多包括了第0列的状态，最后一列多包括了上一行的状态，（如果三角形都是正数，那么边界可以初始化为0，但是这里的三角形可能是负数，因此需要把边界设置为负无穷）为了去掉无效状态
>for(int i=1;i<=n;i++)
>    for(int j=1;j<=i;j++)cin>>f[i][j];
>    
>    for(int i=2;i<=n;i++){
>        for(int j=1;j<=i;j++){
>           f[i][j]=max(f[i-1][j],f[i-1][j-1])+f[i][j];
>        }
>     }
>     ```
>    
>



## 区间DP

区间dp，意思就是，`f[i][j] 表示i~j这个区间`



### 石子合并

>
>
>**只能合并相邻石子**
>
>（允许合并任意两堆石子=>贪心）
>
>状态表示，`f[i][j]` 集合：所有将第i~j堆石子合并到一起的合并方式， 属性：min合并代价
>
>```cpp
>    for(int i=1;i<=n;i++)cin>>s[i];
>    for(int i=1;i<=n;i++)s[i]+=s[i-1]; // 前缀和
>    
>    for(int len=2;len<=n;len++)
>    for(int i=1;i+len-1<=n;i++)
>    {
>        int l=i,r=i+len-1;
>        f[l][r]=1e8;
>        for(int k=l;k<r;k++)
>        f[l][r]=min(f[l][r], f[l][k]+f[k+1][r]+s[r]-s[l-1]);
>    }
>    cout<<f[1][n]<<endl;
>```
>
>

